/**
 * Build script to embed static assets into a single TypeScript file
 * This enables creating a single executable with all assets bundled
 */

import { readdir, readFile, writeFile, mkdir } from 'fs/promises'
import { join, relative, extname } from 'path'

const ROOT = join(import.meta.dir, '..')
const PUBLIC_DIR = join(ROOT, 'public')
const TEMPLATES_DIR = join(ROOT, 'templates')
const OUTPUT_FILE = join(ROOT, 'src', 'embedded-assets.ts')

// MIME types for common file extensions
const MIME_TYPES: Record<string, string> = {
  '.html': 'text/html',
  '.css': 'text/css',
  '.js': 'application/javascript',
  '.json': 'application/json',
  '.png': 'image/png',
  '.jpg': 'image/jpeg',
  '.jpeg': 'image/jpeg',
  '.gif': 'image/gif',
  '.svg': 'image/svg+xml',
  '.ico': 'image/x-icon',
  '.woff': 'font/woff',
  '.woff2': 'font/woff2',
  '.ttf': 'font/ttf',
  '.eot': 'application/vnd.ms-fontobject',
}

interface EmbeddedFile {
  path: string
  content: string
  mimeType: string
  isBase64: boolean
}

async function getAllFiles(dir: string, baseDir: string = dir): Promise<string[]> {
  const files: string[] = []

  try {
    const entries = await readdir(dir, { withFileTypes: true })

    for (const entry of entries) {
      const fullPath = join(dir, entry.name)

      if (entry.isDirectory()) {
        files.push(...await getAllFiles(fullPath, baseDir))
      } else if (entry.isFile() && !entry.name.startsWith('.')) {
        files.push(fullPath)
      }
    }
  } catch {
    // Directory doesn't exist
  }

  return files
}

function isTextFile(ext: string): boolean {
  const textExtensions = ['.html', '.css', '.js', '.json', '.txt', '.md', '.eta', '.svg']
  return textExtensions.includes(ext.toLowerCase())
}

async function embedFiles(dir: string, prefix: string): Promise<EmbeddedFile[]> {
  const files = await getAllFiles(dir)
  const embedded: EmbeddedFile[] = []

  for (const file of files) {
    const relativePath = '/' + prefix + '/' + relative(dir, file).replace(/\\/g, '/')
    const ext = extname(file).toLowerCase()
    const content = await readFile(file)
    const mimeType = MIME_TYPES[ext] || 'application/octet-stream'
    const isText = isTextFile(ext)

    embedded.push({
      path: relativePath,
      content: isText ? content.toString('utf-8') : content.toString('base64'),
      mimeType,
      isBase64: !isText,
    })
  }

  return embedded
}

async function main() {
  console.log('Embedding assets...')

  // Embed public files
  const publicFiles = await embedFiles(PUBLIC_DIR, 'public')
  console.log(`  - Embedded ${publicFiles.length} public files`)

  // Embed template files
  const templateFiles = await embedFiles(TEMPLATES_DIR, 'templates')
  console.log(`  - Embedded ${templateFiles.length} template files`)

  // Generate TypeScript file
  const allFiles = [...publicFiles, ...templateFiles]

  const output = `/**
 * Auto-generated embedded assets
 * DO NOT EDIT - Generated by scripts/embed-assets.ts
 */

export interface EmbeddedAsset {
  content: string
  mimeType: string
  isBase64: boolean
}

// Check if running as compiled executable
// In compiled mode, Bun.main starts with /$bunfs/ (Bun's virtual filesystem for bundled files)
export const IS_COMPILED = typeof Bun !== 'undefined' &&
  (Bun.main?.startsWith('/$bunfs/') || Bun.main?.startsWith('$bunfs/'))

const assets: Record<string, EmbeddedAsset> = {
${allFiles.map(f => `  ${JSON.stringify(f.path)}: {
    content: ${JSON.stringify(f.content)},
    mimeType: ${JSON.stringify(f.mimeType)},
    isBase64: ${f.isBase64},
  }`).join(',\n')}
}

/**
 * Get embedded asset by path
 */
export function getAsset(path: string): EmbeddedAsset | null {
  // Normalize path
  const normalized = path.startsWith('/') ? path : '/' + path
  return assets[normalized] || null
}

/**
 * Get embedded asset content as Buffer
 */
export function getAssetBuffer(path: string): Buffer | null {
  const asset = getAsset(path)
  if (!asset) return null

  if (asset.isBase64) {
    return Buffer.from(asset.content, 'base64')
  }
  return Buffer.from(asset.content, 'utf-8')
}

/**
 * Get embedded asset content as string
 */
export function getAssetString(path: string): string | null {
  const asset = getAsset(path)
  if (!asset) return null

  if (asset.isBase64) {
    return Buffer.from(asset.content, 'base64').toString('utf-8')
  }
  return asset.content
}

/**
 * Get all template files
 */
export function getTemplates(): Record<string, string> {
  const templates: Record<string, string> = {}

  for (const [path, asset] of Object.entries(assets)) {
    if (path.startsWith('/templates/') && path.endsWith('.eta')) {
      const name = path.replace('/templates/', '').replace('.eta', '')
      templates[name] = asset.content
    }
  }

  return templates
}

/**
 * Get all public files for static serving
 */
export function getPublicFiles(): Map<string, { content: Buffer; mimeType: string }> {
  const files = new Map<string, { content: Buffer; mimeType: string }>()

  for (const [path, asset] of Object.entries(assets)) {
    if (path.startsWith('/public/')) {
      const servePath = path.replace('/public', '')
      const content = asset.isBase64
        ? Buffer.from(asset.content, 'base64')
        : Buffer.from(asset.content, 'utf-8')
      files.set(servePath, { content, mimeType: asset.mimeType })
    }
  }

  return files
}
`

  await writeFile(OUTPUT_FILE, output, 'utf-8')
  console.log(`Generated ${OUTPUT_FILE}`)
  console.log(`Total assets: ${allFiles.length}`)
}

main().catch(console.error)
