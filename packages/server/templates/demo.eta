<!DOCTYPE html>
<html lang="<%= it.locale %>"<% if (it.theme) { %> data-theme="<%= it.theme %>"<% } %>>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title><%= it.t('demo.title') %></title>
  <link rel="stylesheet" href="/css/theme.css">
  <% if (it.hasCustomTheme) { %><link rel="stylesheet" href="/css/custom-theme.css"><% } %>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--color-bg-primary);
      min-height: 100vh;
      padding: 40px 20px;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      padding:14px;
    }

    h1 {
      text-align: center;
      color: var(--color-text-primary);
      margin-bottom: 8px;
    }

    .subtitle {
      text-align: center;
      color: var(--color-text-secondary);
      margin-bottom: 40px;
    }

    .card {
      background: var(--color-bg-secondary);
      border-radius: var(--radius-lg);
      padding: 24px;
      margin-bottom: 24px;
      box-shadow: var(--shadow-card);
    }

    .card h2 {
      font-size: 18px;
      color: var(--color-text-primary);
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--color-border);
    }

    .qr-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 24px;
    }

    #qrcode {
      background: white;
      padding: 16px;
      border-radius: var(--radius-md);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .session-url-container {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 16px;
      max-width: 100%;
    }

    .session-url {
      flex: 1;
      padding: 12px 16px;
      background: var(--color-bg-tertiary);
      border-radius: var(--radius-sm);
      font-family: monospace;
      font-size: 14px;
      word-break: break-all;
      color: var(--color-text-primary);
    }

    .btn-copy {
      padding: 12px 16px;
      background: var(--color-accent);
      color: white;
      border: none;
      border-radius: var(--radius-sm);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }

    .btn-copy:hover {
      background: var(--color-accent-hover);
    }

    .btn-copy.copied {
      background: var(--color-success);
    }

    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 500;
    }

    .status-badge.disconnected {
      background: var(--color-error-bg);
      color: var(--color-error);
    }

    .status-badge.connecting {
      background: var(--color-warning-bg);
      color: var(--color-warning);
    }

    .status-badge.connected {
      background: var(--color-success-bg);
      color: var(--color-success);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .status-badge.disconnected .status-dot {
      background: var(--color-error);
    }

    .status-badge.connecting .status-dot {
      background: var(--color-warning);
      animation: pulse 1s infinite;
    }

    .status-badge.connected .status-dot {
      background: var(--color-success);
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .info-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-top: 16px;
    }

    .info-item {
      background: var(--color-bg-tertiary);
      padding: 16px;
      border-radius: var(--radius-md);
      margin-bottom:12px;
    }

    .info-label {
      font-size: 12px;
      color: var(--color-text-muted);
      text-transform: uppercase;
      margin-bottom: 4px;
    }

    .info-value {
      font-family: monospace;
      font-size: 14px;
      color: var(--color-text-primary);
      word-break: break-all;
    }

    .btn-group {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 16px;
    }

    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: var(--radius-sm);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-primary {
      background: var(--color-accent);
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      background: var(--color-accent-hover);
    }

    .btn-secondary {
      background: var(--color-bg-tertiary);
      color: var(--color-text-primary);
    }

    .btn-secondary:hover:not(:disabled) {
      filter: brightness(0.95);
    }

    .btn-danger {
      background: var(--color-error);
      color: white;
    }

    .btn-danger:hover:not(:disabled) {
      filter: brightness(0.9);
    }

    .result-box {
      margin-top: 16px;
      padding: 16px;
      background: #1a1a2e;
      border-radius: var(--radius-md);
      max-height: 300px;
      overflow-y: auto;
    }

    .result-box pre {
      font-family: monospace;
      font-size: 13px;
      color: #4ade80;
      white-space: pre-wrap;
      word-break: break-all;
    }

    .result-box .error {
      color: #f87171;
    }

    .result-box .info {
      color: #60a5fa;
    }

    .hidden {
      display: none !important;
    }

    /* Fixed buttons */
    .fixed-btns {
      position: fixed;
      top: 16px;
      right: 16px;
      z-index: 1000;
      display: flex;
      gap: 8px;
    }

    .fixed-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 1px solid var(--color-border);
      background: var(--color-bg-secondary);
      color: var(--color-text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      box-shadow: var(--shadow-sm);
      transition: all 0.2s;
    }

    .fixed-btn:hover {
      border-color: var(--color-accent);
      color: var(--color-accent);
    }

    .lang-btn {
      width: auto;
      padding: 0 14px;
      border-radius: 20px;
      font-size: 13px;
      font-weight: 500;
    }

    .toggle-btn {
      padding: 6px 14px;
      border: 1px solid var(--color-border);
      border-radius: 6px;
      background: var(--color-bg-secondary);
      color: var(--color-text-secondary);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .toggle-btn:hover {
      border-color: var(--color-accent);
      color: var(--color-accent);
    }

    .toggle-btn.active {
      background: var(--color-accent);
      border-color: var(--color-accent);
      color: white;
    }
  </style>
</head>
<body>
  <div class="fixed-btns">
    <select class="fixed-btn lang-btn" id="langSelect" onchange="changeLang(this.value)" title="Language">
      <% const localeNames = { en: 'English', zh: '‰∏≠Êñá', ja: 'Êó•Êú¨Ë™û', ko: 'ÌïúÍµ≠Ïñ¥', es: 'Espa√±ol', fr: 'Fran√ßais', de: 'Deutsch' } %>
      <% (it.availableLocales || ['en', 'zh']).forEach(loc => { %>
        <option value="<%= loc %>" <%= it.locale === loc ? 'selected' : '' %>><%= localeNames[loc] || loc.toUpperCase() %></option>
      <% }) %>
    </select>
    <button class="fixed-btn" onclick="toggleTheme()" title="Toggle theme">
      <span id="themeIcon"></span>
    </button>
  </div>

  <div class="container">
    <h1><%= it.t('demo.title') %></h1>
    <p class="subtitle"><%= it.t('demo.subtitle') %></p>

    <!-- Connect Card -->
    <div class="card" id="connectCard">
      <h2><%= it.t('demo.connectWallet') %></h2>

      <!-- QR Code area - hidden until connection created -->
      <div class="qr-container hidden" id="qrContainer">
        <div id="qrcode"></div>
        <p style="margin-top: 16px; color: var(--color-text-secondary); font-size: 14px; text-align: center;">
          <% if (it.locale === 'zh') { %>‰ΩøÁî®ÊâãÊú∫Èí±ÂåÖÊâ´Êèè‰∫åÁª¥Á†ÅËøûÊé•<% } else { %>Scan QR code with your mobile wallet<% } %>
        </p>
        <div class="session-url-container">
          <div class="session-url" id="sessionUrl"></div>
          <button class="btn-copy" id="copyBtn" onclick="copySessionUrl()"><%= it.t('common.copy') %></button>
        </div>
      </div>

      <!-- Config section - shown before connection -->
      <div id="configSection">
        <div class="config-section" style="background: var(--color-bg-tertiary); border-radius: var(--radius-md); padding: 16px; margin-bottom: 20px;">
          <div class="config-title" style="font-size: 13px; color: var(--color-text-muted); margin-bottom: 12px; text-transform: uppercase;">
            <% if (it.locale === 'zh') { %>ËøûÊé•ÈÖçÁΩÆ<% } else { %>Connection Config<% } %>
          </div>
          <div class="config-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;">
            <div class="config-item">
              <label style="display: block; color: var(--color-text-secondary); font-size: 12px; margin-bottom: 4px;"><% if (it.locale === 'zh') { %>Â∫îÁî®ÂêçÁß∞<% } else { %>App Name<% } %></label>
              <input type="text" id="appName" value="Remote Inject Demo" style="width: 100%; padding: 8px 12px; border-radius: 6px; border: 1px solid var(--color-border); background: var(--color-bg-secondary); color: var(--color-text-primary); font-size: 14px;">
            </div>
            <div class="config-item">
              <label style="display: block; color: var(--color-text-secondary); font-size: 12px; margin-bottom: 4px;"><% if (it.locale === 'zh') { %>Â∫îÁî® URL<% } else { %>App URL<% } %></label>
              <input type="text" id="appUrl" placeholder="https://example.com" style="width: 100%; padding: 8px 12px; border-radius: 6px; border: 1px solid var(--color-border); background: var(--color-bg-secondary); color: var(--color-text-primary); font-size: 14px;">
            </div>
            <div class="config-item">
              <label style="display: block; color: var(--color-text-secondary); font-size: 12px; margin-bottom: 4px;"><% if (it.locale === 'zh') { %>Logo URL<% } else { %>Logo URL<% } %></label>
              <input type="text" id="appIcon" placeholder="https://example.com/icon.png" style="width: 100%; padding: 8px 12px; border-radius: 6px; border: 1px solid var(--color-border); background: var(--color-bg-secondary); color: var(--color-text-primary); font-size: 14px;">
            </div>
          </div>
          <!-- Wallet page options as button groups -->
          <div style="display: flex; flex-wrap: wrap; gap: 24px; margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--color-border);">
            <div class="config-item" style="flex: 1; min-width: 200px;">
              <label style="display: block; color: var(--color-text-secondary); font-size: 12px; margin-bottom: 8px;"><% if (it.locale === 'zh') { %>Èí±ÂåÖÈ°µËØ≠Ë®Ä<% } else { %>Wallet Language<% } %></label>
              <div class="toggle-group" id="walletLangGroup" style="display: flex; flex-wrap: wrap; gap: 6px;">
                <button type="button" class="toggle-btn active" data-value="" onclick="setWalletLang('')"><% if (it.locale === 'zh') { %>Ëá™Âä®<% } else { %>Auto<% } %></button>
                <% (it.availableLocales || ['en', 'zh']).forEach(loc => { %>
                  <button type="button" class="toggle-btn" data-value="<%= loc %>" onclick="setWalletLang('<%= loc %>')"><%= localeNames[loc] || loc.toUpperCase() %></button>
                <% }) %>
              </div>
              <input type="hidden" id="walletLang" value="">
            </div>
            <div class="config-item" style="flex: 1; min-width: 200px;">
              <label style="display: block; color: var(--color-text-secondary); font-size: 12px; margin-bottom: 8px;"><% if (it.locale === 'zh') { %>Èí±ÂåÖÈ°µ‰∏ªÈ¢ò<% } else { %>Wallet Theme<% } %></label>
              <div class="toggle-group" id="walletThemeGroup" style="display: flex; flex-wrap: wrap; gap: 6px;">
                <button type="button" class="toggle-btn active" data-value="" onclick="setWalletTheme('')"><% if (it.locale === 'zh') { %>Ëá™Âä®<% } else { %>Auto<% } %></button>
                <button type="button" class="toggle-btn" data-value="light" onclick="setWalletTheme('light')"><% if (it.locale === 'zh') { %>ÊµÖËâ≤<% } else { %>Light<% } %></button>
                <button type="button" class="toggle-btn" data-value="dark" onclick="setWalletTheme('dark')"><% if (it.locale === 'zh') { %>Ê∑±Ëâ≤<% } else { %>Dark<% } %></button>
              </div>
              <input type="hidden" id="walletTheme" value="">
            </div>
          </div>
        </div>
      </div>

      <div class="btn-group" style="justify-content: center;">
        <button class="btn btn-primary" id="connectBtn" onclick="startConnect()"><%= it.t('demo.createConnection') %></button>
        <button class="btn btn-danger hidden" id="disconnectBtn" onclick="disconnect()"><%= it.t('demo.disconnectConnection') %></button>
      </div>
    </div>

    <!-- Status Card -->
    <div class="card">
      <h2><%= it.t('demo.connectionStatus') %></h2>
      <div class="status-badge disconnected" id="statusBadge">
        <div class="status-dot"></div>
        <span id="statusText"><%= it.t('demo.notConnected') %></span>
      </div>
      <div class="info-grid" id="walletInfo" style="display: none;">
        <div class="info-item">
          <div class="info-label"><%= it.t('bridge.address') %></div>
          <div class="info-value" id="walletAddress">-</div>
        </div>
        <div class="info-item">
          <div class="info-label"><% if (it.locale === 'zh') { %>Èìæ ID<% } else { %>Chain ID<% } %></div>
          <div class="info-value" id="walletChainId">-</div>
        </div>
        <div class="info-item">
          <div class="info-label">Session</div>
          <div class="info-value" id="walletSession">-</div>
        </div>
      </div>
    </div>

    <!-- Test Card -->
    <div class="card">
      <h2><%= it.t('demo.testActions') %></h2>
      <div class="btn-group">
        <button class="btn btn-secondary" id="btnAccounts" onclick="testGetAccounts()" disabled><%= it.t('demo.getAccounts') %></button>
        <button class="btn btn-secondary" id="btnChainId" onclick="testGetChainId()" disabled><%= it.t('demo.getChainId') %></button>
        <button class="btn btn-secondary" id="btnBalance" onclick="testGetBalance()" disabled><%= it.t('demo.getBalance') %></button>
        <button class="btn btn-primary" id="btnSign" onclick="testPersonalSign()" disabled><%= it.t('demo.signMessage') %></button>
        <button class="btn btn-primary" id="btnSend" onclick="testSendTransaction()" disabled><%= it.t('demo.sendTransaction') %></button>
      </div>
      <div class="result-box">
        <pre id="resultOutput">// <% if (it.locale === 'zh') { %>ÊµãËØïÁªìÊûúÂ∞ÜÊòæÁ§∫Âú®ËøôÈáå<% } else { %>Test results will appear here<% } %></pre>
      </div>
    </div>
  </div>

  <!-- QRCode Library -->
  <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
  <script src="/js/common.js"></script>

  <!-- i18n data (embedded as JSON to avoid script parsing issues) -->
  <script type="application/json" id="i18n-data"><%~ it.translationsJson %></script>

  <script type="module">
    // i18n translations (from server)
    const I18N = JSON.parse(document.getElementById('i18n-data').textContent)
    const LOCALE = '<%= it.locale %>'

    // Translate function
    function t(key, params = {}) {
      let text = I18N[key] || key
      Object.entries(params).forEach(([k, v]) => {
        text = text.replace(new RegExp(`\\{${k}\\}`, 'g'), v)
      })
      return text
    }

    // Theme toggle
    window.toggleTheme = function() {
      ThemeManager.toggle()
      updateThemeIcon()
    }

    function updateThemeIcon() {
      const icon = document.getElementById('themeIcon')
      icon.textContent = ThemeManager.current === 'dark' ? '‚òÄÔ∏è' : 'üåô'
    }

    updateThemeIcon()

    // Set default appUrl to current origin
    document.getElementById('appUrl').value = window.location.origin

    // Language change
    window.changeLang = function(newLang) {
      if (newLang === '<%= it.locale %>') return
      // Set cookie for server-side persistence
      document.cookie = `locale=${newLang};path=/;max-age=31536000;SameSite=Lax`
      localStorage.setItem('locale', newLang)
      // Redirect without lang param (cookie will handle it)
      const url = new URL(window.location.href)
      url.searchParams.delete('lang')
      window.location.href = url.toString()
    }

    // Wallet lang/theme toggle buttons
    window.setWalletLang = function(value) {
      document.getElementById('walletLang').value = value
      document.querySelectorAll('#walletLangGroup .toggle-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.value === value)
      })
    }

    window.setWalletTheme = function(value) {
      document.getElementById('walletTheme').value = value
      document.querySelectorAll('#walletThemeGroup .toggle-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.value === value)
      })
    }

    // Session storage key
    const SESSION_STORAGE_KEY = 'remoteInject_session'

    // Save session to localStorage
    function saveSession(sessionData) {
      try {
        localStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify({
          ...sessionData,
          savedAt: Date.now()
        }))
      } catch (e) {
        console.error('[Demo] Failed to save session:', e)
      }
    }

    // Load session from localStorage
    function loadSession() {
      try {
        const stored = localStorage.getItem(SESSION_STORAGE_KEY)
        if (!stored) return null
        const session = JSON.parse(stored)
        // Session expires after 24 hours
        if (Date.now() - session.savedAt > 24 * 60 * 60 * 1000) {
          clearSession()
          return null
        }
        return session
      } catch (e) {
        console.error('[Demo] Failed to load session:', e)
        return null
      }
    }

    // Clear session from localStorage
    function clearSession() {
      try {
        localStorage.removeItem(SESSION_STORAGE_KEY)
      } catch (e) {
        console.error('[Demo] Failed to clear session:', e)
      }
    }

    // Check if session is still valid on server
    async function checkSessionValid(sessionId) {
      try {
        const res = await fetch(`/session/${sessionId}`)
        if (!res.ok) return false
        const data = await res.json()
        return data.status !== 'expired'
      } catch (e) {
        return false
      }
    }

    // Inline Provider code (simplified for demo)
    class RemoteProvider {
      constructor() {
        this.ws = null
        this.serverUrl = ''
        this.sessionId = ''
        this.sessionUrl = ''
        this.secret = ''  // Store secret for reconnection
        this.requestId = 0
        this.pendingRequests = new Map()
        this.eventListeners = new Map()
        this._chainId = '0x1'
        this._accounts = []
        this._connected = false
        this._userInitiatedDisconnect = false
        this._reconnectAttempts = 0
        this._maxReconnectAttempts = 5
        this._reconnectDelay = 1000

        const events = ['connect', 'disconnect', 'chainChanged', 'accountsChanged', 'message', 'reconnecting']
        events.forEach(event => this.eventListeners.set(event, new Set()))
      }

      async connect(serverUrl, metadata = {}) {
        this.serverUrl = serverUrl.replace(/\/$/, '')
        this._userInitiatedDisconnect = false
        this._reconnectAttempts = 0

        const response = await fetch(`${this.serverUrl}/session`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(metadata),
        })

        if (!response.ok) {
          throw new Error(`Failed to create session: ${response.statusText}`)
        }

        const data = await response.json()
        this.sessionId = data.id
        this.sessionUrl = data.url

        // Extract secret from URL for reconnection
        try {
          const url = new URL(data.url)
          this.secret = url.searchParams.get('k') || ''
        } catch (e) {
          this.secret = ''
        }

        await this.connectWebSocket()

        // Save session for persistence
        saveSession({
          serverUrl: this.serverUrl,
          sessionId: this.sessionId,
          sessionUrl: this.sessionUrl,
          secret: this.secret,
          metadata
        })

        return {
          sessionId: this.sessionId,
          url: this.sessionUrl,
        }
      }

      // Resume an existing session
      async resumeSession(sessionData) {
        this.serverUrl = sessionData.serverUrl
        this.sessionId = sessionData.sessionId
        this.sessionUrl = sessionData.sessionUrl
        this.secret = sessionData.secret || ''
        this._userInitiatedDisconnect = false
        this._reconnectAttempts = 0

        // Verify session is still valid
        const isValid = await checkSessionValid(this.sessionId)
        if (!isValid) {
          clearSession()
          throw new Error('Session expired or invalid')
        }

        await this.connectWebSocket()

        return {
          sessionId: this.sessionId,
          url: this.sessionUrl,
        }
      }

      connectWebSocket() {
        return new Promise((resolve, reject) => {
          const wsUrl = this.serverUrl.replace(/^http/, 'ws')
          this.ws = new WebSocket(`${wsUrl}/ws?session=${this.sessionId}&role=dapp`)

          const timeout = setTimeout(() => {
            reject(new Error('WebSocket connection timeout'))
            this.ws?.close()
          }, 10000)

          this.ws.onopen = () => {
            clearTimeout(timeout)
            this._reconnectAttempts = 0  // Reset on successful connection
          }

          this.ws.onmessage = (event) => {
            this.handleMessage(event.data)
            try {
              const msg = JSON.parse(event.data)
              if (msg.type === 'ready') {
                resolve()
              }
            } catch {}
          }

          this.ws.onclose = (event) => {
            this._connected = false

            // Don't reconnect if user initiated disconnect
            if (this._userInitiatedDisconnect) {
              this.emit('disconnect', { code: 4900, message: 'User disconnected', userInitiated: true })
              return
            }

            // Try to reconnect for non-user-initiated disconnects
            if (this._reconnectAttempts < this._maxReconnectAttempts) {
              this._reconnectAttempts++
              const delay = this._reconnectDelay * Math.pow(1.5, this._reconnectAttempts - 1)
              console.log(`[RemoteProvider] Connection lost, reconnecting in ${delay}ms (attempt ${this._reconnectAttempts}/${this._maxReconnectAttempts})`)

              this.emit('reconnecting', { attempt: this._reconnectAttempts, maxAttempts: this._maxReconnectAttempts })

              setTimeout(() => {
                if (!this._userInitiatedDisconnect) {
                  this.connectWebSocket().catch(err => {
                    console.error('[RemoteProvider] Reconnect failed:', err)
                  })
                }
              }, delay)
            } else {
              this.emit('disconnect', { code: 4900, message: 'Connection lost', userInitiated: false })
            }
          }

          this.ws.onerror = (error) => {
            clearTimeout(timeout)
            reject(new Error('WebSocket connection failed'))
          }
        })
      }

      handleMessage(data) {
        try {
          const message = JSON.parse(data)

          switch (message.type) {
            case 'ready':
              break

            case 'connect':
              this._connected = true
              this._accounts = [message.address]
              this._chainId = '0x' + message.chainId.toString(16)
              this.emit('connect', { chainId: this._chainId })
              this.emit('accountsChanged', this._accounts)
              break

            case 'disconnect':
              this._connected = false
              this._accounts = []
              this.emit('disconnect', { code: 4900, message: message.reason || 'Disconnected' })
              break

            case 'response':
              this.handleResponse(message)
              break

            case 'chainChanged':
              this._chainId = '0x' + message.chainId.toString(16)
              this.emit('chainChanged', this._chainId)
              break

            case 'accountsChanged':
              this._accounts = message.accounts
              this.emit('accountsChanged', this._accounts)
              if (message.accounts.length === 0) {
                this._connected = false
                this.emit('disconnect', { code: 4900, message: 'Wallet disconnected' })
              }
              break

            case 'error':
              console.error('[RemoteProvider] Server error:', message)
              break
          }
        } catch (error) {
          console.error('[RemoteProvider] Failed to parse message:', error)
        }
      }

      handleResponse(message) {
        const pending = this.pendingRequests.get(message.id)
        if (!pending) return

        clearTimeout(pending.timeout)
        this.pendingRequests.delete(message.id)

        if (message.error) {
          const error = new Error(message.error.message)
          error.code = message.error.code
          pending.reject(error)
        } else {
          pending.resolve(message.result)
        }
      }

      async request(args) {
        const { method, params } = args

        switch (method) {
          case 'eth_accounts':
            return this._accounts

          case 'eth_chainId':
            return this._chainId

          case 'eth_requestAccounts':
            if (this._connected && this._accounts.length > 0) {
              return this._accounts
            }
            return new Promise((resolve, reject) => {
              const timeout = setTimeout(() => {
                reject({ code: 4001, message: 'User rejected the request' })
              }, 60000)

              const handler = (accounts) => {
                clearTimeout(timeout)
                this.removeListener('accountsChanged', handler)
                resolve(accounts)
              }

              this.on('accountsChanged', handler)
            })
        }

        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
          throw { code: -32000, message: 'Not connected' }
        }

        if (!this._connected) {
          throw { code: -32000, message: 'Mobile wallet not connected' }
        }

        return this.sendRequest(method, params)
      }

      sendRequest(method, params) {
        return new Promise((resolve, reject) => {
          const id = ++this.requestId

          const timeout = setTimeout(() => {
            this.pendingRequests.delete(id)
            reject({ code: -32003, message: 'Request timeout' })
          }, 60000)

          this.pendingRequests.set(id, { resolve, reject, timeout })

          this.ws.send(JSON.stringify({
            type: 'request',
            id,
            method,
            params: params || [],
          }))
        })
      }

      on(event, listener) {
        this.eventListeners.get(event)?.add(listener)
      }

      removeListener(event, listener) {
        this.eventListeners.get(event)?.delete(listener)
      }

      emit(event, ...args) {
        this.eventListeners.get(event)?.forEach(listener => {
          try {
            listener(...args)
          } catch (error) {
            console.error(`[RemoteProvider] Event listener error:`, error)
          }
        })
      }

      disconnect() {
        this._userInitiatedDisconnect = true  // Mark as user-initiated
        if (this.ws) {
          try {
            this.ws.send(JSON.stringify({ type: 'disconnect', reason: 'User initiated' }))
          } catch (e) {}
          this.ws.close()
          this.ws = null
        }
        this._connected = false
        this._accounts = []
        clearSession()  // Clear stored session on user disconnect
      }

      get isConnected() {
        return this._connected
      }

      get accounts() {
        return this._accounts
      }

      get chainId() {
        return this._chainId
      }

      get session() {
        return {
          id: this.sessionId,
          url: this.sessionUrl,
        }
      }
    }

    // Global variables
    let provider = null

    // Update status display
    function updateStatus(status, text) {
      const badge = document.getElementById('statusBadge')
      const statusText = document.getElementById('statusText')

      badge.className = `status-badge ${status}`
      statusText.textContent = text

      const buttons = ['btnAccounts', 'btnChainId', 'btnBalance', 'btnSign', 'btnSend']
      buttons.forEach(id => {
        document.getElementById(id).disabled = status !== 'connected'
      })

      document.getElementById('walletInfo').style.display = status === 'connected' ? 'block' : 'none'
    }

    // Safe: escape HTML special characters
    function escapeHtml(str) {
      if (!str) return ''
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;')
    }

    // Log result (safe: escape message content)
    function logResult(message, type = 'default') {
      const output = document.getElementById('resultOutput')
      const timestamp = new Date().toLocaleTimeString()
      const className = type === 'error' ? 'error' : type === 'info' ? 'info' : ''
      const escapedMessage = escapeHtml(message)
      output.innerHTML = `<span class="${className}">[${timestamp}] ${escapedMessage}</span>\n` + output.innerHTML
    }

    // Start connect
    window.startConnect = async function() {
      try {
        // Clear any existing session when starting new connection
        clearSession()
        document.getElementById('resumeBtn')?.remove()

        document.getElementById('connectBtn').disabled = true
        updateStatus('connecting', t('demo.waitingConnection'))
        logResult(LOCALE === 'zh' ? 'ÂàõÂª∫ Session...' : 'Creating session...', 'info')

        provider = new RemoteProvider()

        // Listen for events
        provider.on('connect', (info) => {
          logResult(LOCALE === 'zh' ? `Â∑≤ËøûÊé•ÔºåÈìæ ID: ${info.chainId}` : `Connected, Chain ID: ${info.chainId}`, 'info')
          updateStatus('connected', t('bridge.connected'))

          document.getElementById('walletAddress').textContent = provider.accounts[0]
          document.getElementById('walletChainId').textContent = provider.chainId
          document.getElementById('walletSession').textContent = provider.session.id
        })

        provider.on('disconnect', (info) => {
          logResult(LOCALE === 'zh' ? `Â∑≤Êñ≠ÂºÄ: ${info.message}` : `Disconnected: ${info.message}`, 'error')
          updateStatus('disconnected', t('demo.notConnected'))

          // Only show connect button if user initiated or max reconnects reached
          if (info.userInitiated || !provider || provider._reconnectAttempts >= provider._maxReconnectAttempts) {
            document.getElementById('connectBtn').classList.remove('hidden')
            document.getElementById('disconnectBtn').classList.add('hidden')
            document.getElementById('connectBtn').disabled = false
            document.getElementById('qrcode').innerHTML = ''
            document.getElementById('sessionUrl').textContent = ''
            document.getElementById('qrContainer').classList.add('hidden')
            document.getElementById('configSection').classList.remove('hidden')
          }
        })

        provider.on('reconnecting', (info) => {
          logResult(LOCALE === 'zh' ? `Ê≠£Âú®ÈáçËøû... (${info.attempt}/${info.maxAttempts})` : `Reconnecting... (${info.attempt}/${info.maxAttempts})`, 'info')
          updateStatus('connecting', LOCALE === 'zh' ? 'ÈáçÊñ∞ËøûÊé•‰∏≠...' : 'Reconnecting...')
        })

        provider.on('chainChanged', (chainId) => {
          logResult(LOCALE === 'zh' ? `ÈìæÂ∑≤ÂàáÊç¢: ${chainId}` : `Chain changed: ${chainId}`, 'info')
          document.getElementById('walletChainId').textContent = chainId
        })

        provider.on('accountsChanged', (accounts) => {
          if (accounts.length > 0) {
            logResult(LOCALE === 'zh' ? `Ë¥¶Êà∑Â∑≤ÂàáÊç¢: ${accounts[0]}` : `Account changed: ${accounts[0]}`, 'info')
            document.getElementById('walletAddress').textContent = accounts[0]
          }
        })

        // Connect to server (pass DApp metadata from config)
        const serverUrl = window.location.origin
        const appName = document.getElementById('appName').value.trim() || 'Remote Inject Demo'
        const appUrl = document.getElementById('appUrl').value.trim() || window.location.origin
        const appIcon = document.getElementById('appIcon').value.trim() || undefined

        const { sessionId, url } = await provider.connect(serverUrl, {
          name: appName,
          url: appUrl,
          icon: appIcon,
        })

        // Show cancel button and QR area, hide config
        document.getElementById('connectBtn').classList.add('hidden')
        document.getElementById('disconnectBtn').classList.remove('hidden')
        document.getElementById('configSection').classList.add('hidden')
        document.getElementById('qrContainer').classList.remove('hidden')

        logResult(LOCALE === 'zh' ? `Session Â∑≤ÂàõÂª∫: ${sessionId}` : `Session created: ${sessionId}`, 'info')
        logResult(LOCALE === 'zh' ? 'Á≠âÂæÖÁßªÂä®Èí±ÂåÖÊâ´Á†Å...' : 'Waiting for mobile wallet to scan...', 'info')

        // Append lang/theme options to URL
        let finalUrl = url
        const walletLang = document.getElementById('walletLang').value
        const walletTheme = document.getElementById('walletTheme').value
        const urlObj = new URL(finalUrl)
        if (walletLang) urlObj.searchParams.set('lang', walletLang)
        if (walletTheme) urlObj.searchParams.set('theme', walletTheme)
        finalUrl = urlObj.toString()

        // Show QR code and link
        document.getElementById('sessionUrl').textContent = finalUrl
        const qrcodeContainer = document.getElementById('qrcode')
        qrcodeContainer.innerHTML = ''
        new QRCode(qrcodeContainer, {
          text: finalUrl,
          width: 220,
          height: 220,
          colorDark: '#1a1a2e',
          colorLight: '#ffffff',
          correctLevel: QRCode.CorrectLevel.M
        })

      } catch (error) {
        logResult(LOCALE === 'zh' ? `ËøûÊé•Â§±Ë¥•: ${error.message}` : `Connection failed: ${error.message}`, 'error')
        updateStatus('disconnected', t('demo.notConnected'))
        document.getElementById('connectBtn').disabled = false
      }
    }

    // Disconnect
    window.disconnect = function() {
      if (provider) {
        provider.disconnect()
        provider = null
      }
      document.getElementById('qrcode').innerHTML = ''
      document.getElementById('sessionUrl').textContent = ''
      document.getElementById('qrContainer').classList.add('hidden')
      document.getElementById('configSection').classList.remove('hidden')
      updateStatus('disconnected', t('demo.notConnected'))
      document.getElementById('connectBtn').classList.remove('hidden')
      document.getElementById('disconnectBtn').classList.add('hidden')
      document.getElementById('connectBtn').disabled = false
    }

    // Resume existing session
    window.resumeSession = async function() {
      const sessionData = loadSession()
      if (!sessionData) {
        logResult(LOCALE === 'zh' ? 'Ê≤°ÊúâÂèØÊÅ¢Â§çÁöÑ‰ºöËØù' : 'No session to resume', 'error')
        return
      }

      try {
        document.getElementById('connectBtn').disabled = true
        document.getElementById('resumeBtn')?.remove()
        updateStatus('connecting', LOCALE === 'zh' ? 'ÊÅ¢Â§çËøûÊé•‰∏≠...' : 'Resuming connection...')
        logResult(LOCALE === 'zh' ? `ÊÅ¢Â§ç Session: ${sessionData.sessionId}` : `Resuming session: ${sessionData.sessionId}`, 'info')

        provider = new RemoteProvider()

        // Listen for events (same as startConnect)
        provider.on('connect', (info) => {
          logResult(LOCALE === 'zh' ? `Â∑≤ËøûÊé•ÔºåÈìæ ID: ${info.chainId}` : `Connected, Chain ID: ${info.chainId}`, 'info')
          updateStatus('connected', t('bridge.connected'))

          document.getElementById('walletAddress').textContent = provider.accounts[0]
          document.getElementById('walletChainId').textContent = provider.chainId
          document.getElementById('walletSession').textContent = provider.session.id
        })

        provider.on('disconnect', (info) => {
          logResult(LOCALE === 'zh' ? `Â∑≤Êñ≠ÂºÄ: ${info.message}` : `Disconnected: ${info.message}`, 'error')
          updateStatus('disconnected', t('demo.notConnected'))

          if (info.userInitiated || !provider || provider._reconnectAttempts >= provider._maxReconnectAttempts) {
            document.getElementById('connectBtn').classList.remove('hidden')
            document.getElementById('disconnectBtn').classList.add('hidden')
            document.getElementById('connectBtn').disabled = false
            document.getElementById('qrcode').innerHTML = ''
            document.getElementById('sessionUrl').textContent = ''
            document.getElementById('qrContainer').classList.add('hidden')
            document.getElementById('configSection').classList.remove('hidden')
          }
        })

        provider.on('reconnecting', (info) => {
          logResult(LOCALE === 'zh' ? `Ê≠£Âú®ÈáçËøû... (${info.attempt}/${info.maxAttempts})` : `Reconnecting... (${info.attempt}/${info.maxAttempts})`, 'info')
          updateStatus('connecting', LOCALE === 'zh' ? 'ÈáçÊñ∞ËøûÊé•‰∏≠...' : 'Reconnecting...')
        })

        provider.on('chainChanged', (chainId) => {
          logResult(LOCALE === 'zh' ? `ÈìæÂ∑≤ÂàáÊç¢: ${chainId}` : `Chain changed: ${chainId}`, 'info')
          document.getElementById('walletChainId').textContent = chainId
        })

        provider.on('accountsChanged', (accounts) => {
          if (accounts.length > 0) {
            logResult(LOCALE === 'zh' ? `Ë¥¶Êà∑Â∑≤ÂàáÊç¢: ${accounts[0]}` : `Account changed: ${accounts[0]}`, 'info')
            document.getElementById('walletAddress').textContent = accounts[0]
          }
        })

        await provider.resumeSession(sessionData)

        // Show QR area, hide config
        document.getElementById('connectBtn').classList.add('hidden')
        document.getElementById('disconnectBtn').classList.remove('hidden')
        document.getElementById('configSection').classList.add('hidden')
        document.getElementById('qrContainer').classList.remove('hidden')

        // Show QR code and link
        let finalUrl = sessionData.sessionUrl
        const walletLang = document.getElementById('walletLang').value
        const walletTheme = document.getElementById('walletTheme').value
        const urlObj = new URL(finalUrl)
        if (walletLang) urlObj.searchParams.set('lang', walletLang)
        if (walletTheme) urlObj.searchParams.set('theme', walletTheme)
        finalUrl = urlObj.toString()

        document.getElementById('sessionUrl').textContent = finalUrl
        const qrcodeContainer = document.getElementById('qrcode')
        qrcodeContainer.innerHTML = ''
        new QRCode(qrcodeContainer, {
          text: finalUrl,
          width: 220,
          height: 220,
          colorDark: '#1a1a2e',
          colorLight: '#ffffff',
          correctLevel: QRCode.CorrectLevel.M
        })

        logResult(LOCALE === 'zh' ? 'Á≠âÂæÖÁßªÂä®Èí±ÂåÖÈáçÊñ∞ËøûÊé•...' : 'Waiting for mobile wallet to reconnect...', 'info')

      } catch (error) {
        logResult(LOCALE === 'zh' ? `ÊÅ¢Â§çÂ§±Ë¥•: ${error.message}` : `Resume failed: ${error.message}`, 'error')
        updateStatus('disconnected', t('demo.notConnected'))
        document.getElementById('connectBtn').disabled = false
        clearSession()
      }
    }

    // Check for existing session on page load
    ;(async function checkExistingSession() {
      const sessionData = loadSession()
      if (sessionData) {
        const isValid = await checkSessionValid(sessionData.sessionId)
        if (isValid) {
          logResult(LOCALE === 'zh' ? `ÂèëÁé∞Êú™ÂÆåÊàêÁöÑ‰ºöËØù: ${sessionData.sessionId}` : `Found existing session: ${sessionData.sessionId}`, 'info')

          // Add resume button
          const connectBtn = document.getElementById('connectBtn')
          const resumeBtn = document.createElement('button')
          resumeBtn.id = 'resumeBtn'
          resumeBtn.className = 'btn btn-secondary'
          resumeBtn.textContent = LOCALE === 'zh' ? 'ÊÅ¢Â§çËøûÊé•' : 'Resume'
          resumeBtn.onclick = resumeSession
          connectBtn.parentNode.insertBefore(resumeBtn, connectBtn)

          // Update connect button text
          connectBtn.textContent = LOCALE === 'zh' ? 'Êñ∞Âª∫ËøûÊé•' : 'New Session'
        } else {
          clearSession()
        }
      }
    })()

    // Copy link
    window.copySessionUrl = async function() {
      const url = document.getElementById('sessionUrl').textContent
      if (!url) return

      try {
        await navigator.clipboard.writeText(url)
        const btn = document.getElementById('copyBtn')
        btn.textContent = t('common.copied')
        btn.classList.add('copied')
        setTimeout(() => {
          btn.textContent = t('common.copy')
          btn.classList.remove('copied')
        }, 2000)
        logResult(LOCALE === 'zh' ? 'ÈìæÊé•Â∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø' : 'Link copied to clipboard', 'info')
      } catch (error) {
        logResult(LOCALE === 'zh' ? 'Â§çÂà∂Â§±Ë¥•: ' + error.message : 'Copy failed: ' + error.message, 'error')
      }
    }

    // Test: get accounts
    window.testGetAccounts = async function() {
      try {
        logResult(LOCALE === 'zh' ? 'Ë∞ÉÁî® eth_accounts...' : 'Calling eth_accounts...', 'info')
        const accounts = await provider.request({ method: 'eth_accounts' })
        logResult(LOCALE === 'zh' ? `Ë¥¶Êà∑: ${JSON.stringify(accounts)}` : `Accounts: ${JSON.stringify(accounts)}`)
      } catch (error) {
        logResult(LOCALE === 'zh' ? `ÈîôËØØ: ${error.message}` : `Error: ${error.message}`, 'error')
      }
    }

    // Test: get chain ID
    window.testGetChainId = async function() {
      try {
        logResult(LOCALE === 'zh' ? 'Ë∞ÉÁî® eth_chainId...' : 'Calling eth_chainId...', 'info')
        const chainId = await provider.request({ method: 'eth_chainId' })
        logResult(LOCALE === 'zh' ? `Èìæ ID: ${chainId} (${parseInt(chainId, 16)})` : `Chain ID: ${chainId} (${parseInt(chainId, 16)})`)
      } catch (error) {
        logResult(LOCALE === 'zh' ? `ÈîôËØØ: ${error.message}` : `Error: ${error.message}`, 'error')
      }
    }

    // Test: get balance
    window.testGetBalance = async function() {
      try {
        logResult(LOCALE === 'zh' ? 'Ë∞ÉÁî® eth_getBalance...' : 'Calling eth_getBalance...', 'info')
        const balance = await provider.request({
          method: 'eth_getBalance',
          params: [provider.accounts[0], 'latest'],
        })
        const eth = parseInt(balance, 16) / 1e18
        logResult(LOCALE === 'zh' ? `‰ΩôÈ¢ù: ${balance} (${eth.toFixed(6)} ETH)` : `Balance: ${balance} (${eth.toFixed(6)} ETH)`)
      } catch (error) {
        logResult(LOCALE === 'zh' ? `ÈîôËØØ: ${error.message}` : `Error: ${error.message}`, 'error')
      }
    }

    // Test: sign message
    window.testPersonalSign = async function() {
      try {
        const message = 'Hello from Remote Inject! ' + new Date().toISOString()
        logResult(LOCALE === 'zh' ? `Ë∞ÉÁî® personal_sign: "${message}"` : `Calling personal_sign: "${message}"`, 'info')

        const signature = await provider.request({
          method: 'personal_sign',
          params: [
            '0x' + Array.from(new TextEncoder().encode(message)).map(b => b.toString(16).padStart(2, '0')).join(''),
            provider.accounts[0],
          ],
        })
        logResult(LOCALE === 'zh' ? `Á≠æÂêç: ${signature}` : `Signature: ${signature}`)
      } catch (error) {
        logResult(LOCALE === 'zh' ? `ÈîôËØØ: ${error.message}` : `Error: ${error.message}`, 'error')
      }
    }

    // Test: send transaction
    window.testSendTransaction = async function() {
      try {
        logResult(LOCALE === 'zh' ? 'Ë∞ÉÁî® eth_sendTransaction (ÂèëÈÄÅ 0 ETH Âà∞Ëá™Â∑±)...' : 'Calling eth_sendTransaction (sending 0 ETH to self)...', 'info')

        const txHash = await provider.request({
          method: 'eth_sendTransaction',
          params: [{
            from: provider.accounts[0],
            to: provider.accounts[0],
            value: '0x0',
          }],
        })
        logResult(LOCALE === 'zh' ? `‰∫§ÊòìÂìàÂ∏å: ${txHash}` : `Transaction hash: ${txHash}`)
      } catch (error) {
        logResult(LOCALE === 'zh' ? `ÈîôËØØ: ${error.message}` : `Error: ${error.message}`, 'error')
      }
    }
  </script>
</body>
</html>
