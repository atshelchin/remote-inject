<!DOCTYPE html>
<html lang="<%= it.locale %>"<% if (it.theme) { %> data-theme="<%= it.theme %>"<% } %>>
<head>
  <%~ include('partials/head', it) %>
  <title><%= it.t('demo.title') %></title>
  <style>
    /* Demo page specific styles */
    body {
      min-height: 100vh;
      padding: 40px 20px;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 14px;
    }

    h1 {
      text-align: center;
      color: var(--color-text-primary);
      margin-bottom: 8px;
    }

    .subtitle {
      text-align: center;
      color: var(--color-text-secondary);
      margin-bottom: 40px;
    }

    .card {
      margin-bottom: 24px;
    }

    .qr-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 24px;
    }

    #qrcode {
      background: white;
      padding: 16px;
      border-radius: var(--radius-md);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .session-url-container {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 16px;
      max-width: 100%;
    }

    .session-url {
      flex: 1;
      padding: 12px 16px;
      background: var(--color-bg-tertiary);
      border-radius: var(--radius-sm);
      font-family: monospace;
      font-size: 14px;
      word-break: break-all;
      color: var(--color-text-primary);
    }

    .btn-copy {
      padding: 12px 16px;
      background: var(--color-accent);
      color: white;
      border: none;
      border-radius: var(--radius-sm);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }

    .btn-copy:hover {
      background: var(--color-accent-hover);
    }

    .btn-copy.copied {
      background: var(--color-success);
    }

    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 500;
      margin-bottom:12px;
    }

    .status-badge.disconnected {
      background: var(--color-error-bg);
      color: var(--color-error);
    }

    .status-badge.connecting {
      background: var(--color-warning-bg);
      color: var(--color-warning);
    }

    .status-badge.connected {
      background: var(--color-success-bg);
      color: var(--color-success);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .status-badge.disconnected .status-dot {
      background: var(--color-error);
    }

    .status-badge.connecting .status-dot {
      background: var(--color-warning);
      animation: status-pulse 1s infinite;
    }

    .status-badge.connected .status-dot {
      background: var(--color-success);
    }

    @keyframes status-pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .info-item {
      margin-bottom: 12px;
    }

    .btn-group {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 16px;
    }

    .result-box {
      margin-top: 16px;
      padding: 16px;
      background: #1a1a2e;
      border-radius: var(--radius-md);
      max-height: 300px;
      overflow-y: auto;
    }

    .result-box pre {
      font-family: monospace;
      font-size: 13px;
      color: #4ade80;
      white-space: pre-wrap;
      word-break: break-all;
    }

    .result-box .error {
      color: #f87171;
    }

    .result-box .info {
      color: #60a5fa;
    }

    /* Fixed buttons */
    .fixed-btns {
      position: fixed;
      top: 16px;
      right: 16px;
      z-index: 1000;
      display: flex;
      gap: 8px;
    }

    .fixed-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 1px solid var(--color-border);
      background: var(--color-bg-secondary);
      color: var(--color-text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      box-shadow: var(--shadow-sm);
      transition: all 0.2s;
    }

    .fixed-btn:hover {
      border-color: var(--color-accent);
      color: var(--color-accent);
    }

    .lang-btn {
      width: auto;
      padding: 0 14px;
      border-radius: 20px;
      font-size: 13px;
      font-weight: 500;
    }

    .toggle-btn {
      padding: 6px 14px;
      border: 1px solid var(--color-border);
      border-radius: 6px;
      background: var(--color-bg-secondary);
      color: var(--color-text-secondary);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .toggle-btn:hover {
      border-color: var(--color-accent);
      color: var(--color-accent);
    }

    .toggle-btn.active {
      background: var(--color-accent);
      border-color: var(--color-accent);
      color: white;
    }

    /* Action groups */
    .action-group {
      margin-bottom: 20px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--color-border);
    }

    .action-group:last-of-type {
      border-bottom: none;
      margin-bottom: 0;
    }

    .action-group-title {
      font-size: 13px;
      font-weight: 500;
      color: var(--color-text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 12px;
    }

    .chain-switch-group {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
    }

    /* Unified select styling - matches btn-secondary */
    .styled-select {
      appearance: none;
      -webkit-appearance: none;
      padding: 12px 36px 12px 16px;
      border: none;
      border-radius: var(--radius-md);
      background: var(--color-bg-tertiary);
      color: var(--color-text-primary);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%236b7280' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 14px center;
    }

    .styled-select:hover:not(:disabled) {
      filter: brightness(0.95);
    }

    .styled-select:focus {
      outline: none;
      box-shadow: 0 0 0 2px var(--color-accent);
    }

    .styled-select:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .styled-select option {
      background: var(--color-bg-secondary);
      color: var(--color-text-primary);
      padding: 8px;
    }

    .chain-select {
      min-width: 160px;
    }

    /* Account list in status card */
    .account-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }

    .account-item {
      padding: 8px 14px;
      background: var(--color-bg-tertiary);
      border: 2px solid transparent;
      border-radius: var(--radius-md);
      font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      font-size: 13px;
      color: var(--color-text-primary);
      cursor: pointer;
      transition: all 0.15s;
    }

    .account-item:hover:not([data-empty]) {
      border-color: var(--color-accent);
    }

    .account-item.active {
      background: var(--color-accent);
      color: white;
      border-color: var(--color-accent);
    }

    .account-item.active::before {
      content: '‚óè ';
    }

    .account-item[data-empty] {
      cursor: default;
      color: var(--color-text-muted);
    }

    .account-count {
      font-size: 11px;
      color: var(--color-text-muted);
      font-weight: normal;
      margin-left: 4px;
    }

    /* Chain list */
    .chain-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 12px;
    }

    .chain-chip {
      padding: 8px 14px;
      background: var(--color-bg-tertiary);
      border: 2px solid transparent;
      border-radius: var(--radius-md);
      font-size: 13px;
      font-weight: 500;
      color: var(--color-text-primary);
      cursor: pointer;
      transition: all 0.15s;
    }

    .chain-chip:hover:not(:disabled):not(.current) {
      border-color: var(--color-accent);
    }

    .chain-chip:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .chain-chip.current {
      background: var(--color-success-bg);
      color: var(--color-success);
      border-color: var(--color-success);
      cursor: default;
    }

    .chain-chip.current::before {
      content: '‚úì ';
    }

    /* Action items with description */
    .action-items {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .action-item {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .action-item .btn {
      min-width: 120px;
    }

    .action-desc {
      font-size: 13px;
      color: var(--color-text-muted);
    }

    /* Contract form styles */
    .contract-form {
      background: var(--color-bg-tertiary);
      border-radius: var(--radius-md);
      padding: 16px;
    }

    .contract-form .form-title {
      font-size: 13px;
      font-weight: 500;
      color: var(--color-text-secondary);
      margin-bottom: 12px;
    }

    .contract-form .form-row {
      display: flex;
      gap: 8px;
      align-items: flex-start;
    }

    .contract-form .form-input {
      flex: 1;
      padding: 10px 14px;
      font-size: 13px;
      border: 1px solid var(--color-border);
      border-radius: var(--radius-sm);
      background: var(--color-bg-secondary);
      color: var(--color-text-primary);
      font-family: 'SF Mono', Monaco, monospace;
    }

    .contract-form .form-input:focus {
      outline: none;
      border-color: var(--color-accent);
    }

    .contract-form .form-input::placeholder {
      color: var(--color-text-muted);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }

    .contract-form textarea.form-input {
      resize: vertical;
      min-height: 60px;
    }

    /* Method params */
    .method-param {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .method-param label {
      min-width: 120px;
      font-size: 12px;
      color: var(--color-text-secondary);
      font-family: 'SF Mono', Monaco, monospace;
    }

    .method-param .param-type {
      font-size: 11px;
      color: var(--color-text-muted);
      padding: 2px 6px;
      background: var(--color-bg-secondary);
      border-radius: 4px;
    }

    .method-info {
      font-size: 12px;
      color: var(--color-text-muted);
      padding: 8px 12px;
      background: var(--color-bg-secondary);
      border-radius: var(--radius-sm);
      margin-bottom: 8px;
    }

    .method-info .method-type {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 500;
      margin-right: 8px;
    }

    .method-info .method-type.view {
      background: var(--color-success-bg);
      color: var(--color-success);
    }

    .method-info .method-type.payable {
      background: var(--color-warning-bg);
      color: var(--color-warning);
    }

    .method-info .method-type.nonpayable {
      background: var(--color-accent);
      color: white;
    }
  </style>
</head>
<body>
  <div class="fixed-btns">
    <select class="fixed-btn lang-btn" id="langSelect" onchange="changeLang(this.value)" title="Language">
      <% const localeNames = { en: 'English', zh: '‰∏≠Êñá', ja: 'Êó•Êú¨Ë™û', ko: 'ÌïúÍµ≠Ïñ¥', es: 'Espa√±ol', fr: 'Fran√ßais', de: 'Deutsch' } %>
      <% (it.availableLocales || ['en', 'zh']).forEach(loc => { %>
        <option value="<%= loc %>" <%= it.locale === loc ? 'selected' : '' %>><%= localeNames[loc] || loc.toUpperCase() %></option>
      <% }) %>
    </select>
    <button class="fixed-btn" onclick="toggleTheme()" title="Toggle theme">
      <span id="themeIcon"></span>
    </button>
  </div>

  <div class="container">
    <h1><%= it.t('demo.title') %></h1>
    <p class="subtitle"><%= it.t('demo.subtitle') %></p>

    <!-- Connect Card -->
    <div class="card" id="connectCard">
      <h2><%= it.t('demo.connectWallet') %></h2>

      <!-- QR Code area - hidden until connection created -->
      <div class="qr-container hidden" id="qrContainer">
        <div id="qrcode"></div>
        <p style="margin-top: 16px; color: var(--color-text-secondary); font-size: 14px; text-align: center;">
          <% if (it.locale === 'zh') { %>‰ΩøÁî®ÊâãÊú∫Èí±ÂåÖÊâ´Êèè‰∫åÁª¥Á†ÅËøûÊé•<% } else { %>Scan QR code with your mobile wallet<% } %>
        </p>
        <div class="session-url-container">
          <div class="session-url" id="sessionUrl"></div>
          <button class="btn-copy" id="copyBtn" onclick="copySessionUrl()"><%= it.t('common.copy') %></button>
        </div>
      </div>

      <!-- Config section - shown before connection -->
      <div id="configSection">
        <div class="config-section" style="background: var(--color-bg-tertiary); border-radius: var(--radius-md); padding: 16px; margin-bottom: 20px;">
          <div class="config-title" style="font-size: 13px; color: var(--color-text-muted); margin-bottom: 12px; text-transform: uppercase;">
            <% if (it.locale === 'zh') { %>ËøûÊé•ÈÖçÁΩÆ<% } else { %>Connection Config<% } %>
          </div>
          <div class="config-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;">
            <div class="config-item">
              <label style="display: block; color: var(--color-text-secondary); font-size: 12px; margin-bottom: 4px;"><% if (it.locale === 'zh') { %>Â∫îÁî®ÂêçÁß∞<% } else { %>App Name<% } %></label>
              <input type="text" id="appName" value="Remote Inject Demo" style="width: 100%; padding: 8px 12px; border-radius: 6px; border: 1px solid var(--color-border); background: var(--color-bg-secondary); color: var(--color-text-primary); font-size: 14px;">
            </div>
            <div class="config-item">
              <label style="display: block; color: var(--color-text-secondary); font-size: 12px; margin-bottom: 4px;"><% if (it.locale === 'zh') { %>Â∫îÁî® URL<% } else { %>App URL<% } %></label>
              <input type="text" id="appUrl" placeholder="https://example.com" style="width: 100%; padding: 8px 12px; border-radius: 6px; border: 1px solid var(--color-border); background: var(--color-bg-secondary); color: var(--color-text-primary); font-size: 14px;">
            </div>
            <div class="config-item">
              <label style="display: block; color: var(--color-text-secondary); font-size: 12px; margin-bottom: 4px;"><% if (it.locale === 'zh') { %>Logo URL<% } else { %>Logo URL<% } %></label>
              <input type="text" id="appIcon" placeholder="https://example.com/icon.png" style="width: 100%; padding: 8px 12px; border-radius: 6px; border: 1px solid var(--color-border); background: var(--color-bg-secondary); color: var(--color-text-primary); font-size: 14px;">
            </div>
          </div>
          <!-- Wallet page options as button groups -->
          <div style="display: flex; flex-wrap: wrap; gap: 24px; margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--color-border);">
            <div class="config-item" style="flex: 1; min-width: 200px;">
              <label style="display: block; color: var(--color-text-secondary); font-size: 12px; margin-bottom: 8px;"><% if (it.locale === 'zh') { %>Èí±ÂåÖÈ°µËØ≠Ë®Ä<% } else { %>Wallet Language<% } %></label>
              <div class="toggle-group" id="walletLangGroup" style="display: flex; flex-wrap: wrap; gap: 6px;">
                <button type="button" class="toggle-btn active" data-value="" onclick="setWalletLang('')"><% if (it.locale === 'zh') { %>Ëá™Âä®<% } else { %>Auto<% } %></button>
                <% (it.availableLocales || ['en', 'zh']).forEach(loc => { %>
                  <button type="button" class="toggle-btn" data-value="<%= loc %>" onclick="setWalletLang('<%= loc %>')"><%= localeNames[loc] || loc.toUpperCase() %></button>
                <% }) %>
              </div>
              <input type="hidden" id="walletLang" value="">
            </div>
            <div class="config-item" style="flex: 1; min-width: 200px;">
              <label style="display: block; color: var(--color-text-secondary); font-size: 12px; margin-bottom: 8px;"><% if (it.locale === 'zh') { %>Èí±ÂåÖÈ°µ‰∏ªÈ¢ò<% } else { %>Wallet Theme<% } %></label>
              <div class="toggle-group" id="walletThemeGroup" style="display: flex; flex-wrap: wrap; gap: 6px;">
                <button type="button" class="toggle-btn active" data-value="" onclick="setWalletTheme('')"><% if (it.locale === 'zh') { %>Ëá™Âä®<% } else { %>Auto<% } %></button>
                <button type="button" class="toggle-btn" data-value="light" onclick="setWalletTheme('light')"><% if (it.locale === 'zh') { %>ÊµÖËâ≤<% } else { %>Light<% } %></button>
                <button type="button" class="toggle-btn" data-value="dark" onclick="setWalletTheme('dark')"><% if (it.locale === 'zh') { %>Ê∑±Ëâ≤<% } else { %>Dark<% } %></button>
              </div>
              <input type="hidden" id="walletTheme" value="">
            </div>
          </div>
        </div>
      </div>

      <div class="btn-group" style="justify-content: center;">
        <button class="btn btn-primary" id="connectBtn" onclick="startConnect()"><%= it.t('demo.createConnection') %></button>
        <button class="btn btn-danger hidden" id="disconnectBtn" onclick="disconnect()"><%= it.t('demo.disconnectConnection') %></button>
      </div>
    </div>

    <!-- Status Card -->
    <div class="card">
      <h2><%= it.t('demo.connectionStatus') %></h2>
      <div class="status-badge disconnected" id="statusBadge">
        <div class="status-dot"></div>
        <span id="statusText"><%= it.t('demo.notConnected') %></span>
      </div>
      <div class="info-grid" id="walletInfo" style="display: none;">
        <div class="info-item" style="grid-column: 1 / -1;">
          <div class="info-label"><%= it.t('bridge.address') %> <span id="accountCount" class="account-count"></span></div>
          <div class="account-list" id="accountList">
            <div class="account-item" data-empty>-</div>
          </div>
        </div>
        <div class="info-item">
          <div class="info-label"><% if (it.locale === 'zh') { %>Èìæ ID<% } else { %>Chain ID<% } %></div>
          <div class="info-value" id="walletChainId">-</div>
        </div>
        <div class="info-item">
          <div class="info-label">Session</div>
          <div class="info-value" id="walletSession">-</div>
        </div>
      </div>
    </div>

    <!-- Test Card -->
    <div class="card">
      <h2><%= it.t('demo.testActions') %></h2>

      <!-- Chain Actions -->
      <div class="action-group">
        <h3 class="action-group-title"><%= it.t('demo.chainActions') %></h3>
        <div class="btn-group">
          <button class="btn btn-secondary" id="btnChainId" onclick="testGetChainId()" disabled><%= it.t('demo.getChainId') %></button>
          <button class="btn btn-secondary" id="btnBlockNumber" onclick="testGetBlockNumber()" disabled><%= it.t('demo.getBlockNumber') %></button>
        </div>
        <div class="chain-list" id="chainList">
          <button class="chain-chip" data-chain="0x1" disabled>Ethereum</button>
          <button class="chain-chip" data-chain="0x89" disabled>Polygon</button>
          <button class="chain-chip" data-chain="0xa4b1" disabled>Arbitrum</button>
          <button class="chain-chip" data-chain="0xa" disabled>Optimism</button>
          <button class="chain-chip" data-chain="0x38" disabled>BSC</button>
          <button class="chain-chip" data-chain="0xa86a" disabled>Avalanche</button>
          <button class="chain-chip" data-chain="0x2105" disabled>Base</button>
          <button class="chain-chip" data-chain="0xaa36a7" disabled>Sepolia</button>
        </div>
      </div>

      <!-- Account Actions -->
      <div class="action-group">
        <h3 class="action-group-title"><%= it.t('demo.accountActions') %></h3>
        <div class="action-items">
          <div class="action-item">
            <button class="btn btn-secondary" id="btnAccounts" onclick="testGetAccounts()" disabled><%= it.t('demo.getAccounts') %></button>
            <span class="action-desc"><% if (it.locale === 'zh') { %>Êü•ËØ¢Â∑≤ÊéàÊùÉÁöÑË¥¶Êà∑ÂàóË°®<% } else { %>Query authorized accounts<% } %></span>
          </div>
          <div class="action-item">
            <button class="btn btn-secondary" id="btnRequestAccounts" onclick="testRequestAccounts()" disabled><%= it.t('demo.requestAccounts') %></button>
            <span class="action-desc"><% if (it.locale === 'zh') { %>ÂºπÂá∫Èí±ÂåÖËØ∑Ê±ÇÁî®Êà∑ÊéàÊùÉ<% } else { %>Popup wallet for user authorization<% } %></span>
          </div>
          <div class="action-item">
            <button class="btn btn-secondary" id="btnBalance" onclick="testGetBalance()" disabled><%= it.t('demo.getBalance') %></button>
            <span class="action-desc"><% if (it.locale === 'zh') { %>Êü•ËØ¢ÂΩìÂâçË¥¶Êà∑‰ΩôÈ¢ù<% } else { %>Query current account balance<% } %></span>
          </div>
        </div>
      </div>

      <!-- Sign Actions -->
      <div class="action-group">
        <h3 class="action-group-title"><%= it.t('demo.signActions') %></h3>
        <div class="btn-group">
          <button class="btn btn-primary" id="btnSign" onclick="testPersonalSign()" disabled><%= it.t('demo.signMessage') %></button>
          <button class="btn btn-primary" id="btnSignTypedData" onclick="testSignTypedData()" disabled><%= it.t('demo.signTypedData') %></button>
          <button class="btn btn-primary" id="btnSend" onclick="testSendTransaction()" disabled><%= it.t('demo.sendTransaction') %></button>
        </div>
      </div>

      <!-- Contract Actions -->
      <div class="action-group">
        <h3 class="action-group-title"><%= it.t('demo.contractActions') %></h3>
        <div class="btn-group">
          <button class="btn btn-secondary" id="btnReadContract" onclick="testReadContract()" disabled><%= it.t('demo.readContract') %></button>
          <button class="btn btn-secondary" id="btnEstimateGas" onclick="testEstimateGas()" disabled><%= it.t('demo.estimateGas') %></button>
        </div>

        <!-- Custom Transfer -->
        <div class="contract-form" style="margin-top: 16px;">
          <div class="form-title"><% if (it.locale === 'zh') { %>Ëá™ÂÆö‰πâËΩ¨Ë¥¶<% } else { %>Custom Transfer<% } %></div>
          <div class="form-row">
            <input type="text" class="form-input" id="transferTo" placeholder="<% if (it.locale === 'zh') { %>Êé•Êî∂Âú∞ÂùÄ (0x...)<%} else {%>Recipient Address (0x...)<%}%>">
            <input type="text" class="form-input" id="transferAmount" placeholder="<% if (it.locale === 'zh') { %>ÈáëÈ¢ù (ETH)<%} else {%>Amount (ETH)<%}%>" style="width: 140px;">
            <button class="btn btn-primary" id="btnCustomTransfer" onclick="testCustomTransfer()" disabled><% if (it.locale === 'zh') { %>ÂèëÈÄÅ<% } else { %>Send<% } %></button>
          </div>
        </div>

        <!-- Custom Contract Call -->
        <div class="contract-form" style="margin-top: 16px;">
          <div class="form-title"><% if (it.locale === 'zh') { %>Ëá™ÂÆö‰πâÂêàÁ∫¶Ë∞ÉÁî®<% } else { %>Custom Contract Call<% } %></div>
          <div class="form-row">
            <input type="text" class="form-input" id="contractAddress" placeholder="<% if (it.locale === 'zh') { %>ÂêàÁ∫¶Âú∞ÂùÄ (0x...)<%} else {%>Contract Address (0x...)<%}%>">
          </div>
          <div class="form-row" style="margin-top: 8px;">
            <textarea class="form-input" id="contractAbi" rows="3" placeholder="<% if (it.locale === 'zh') { %>ABI (JSON Êï∞ÁªÑÔºå‰æãÂ¶Ç: [{&quot;name&quot;:&quot;balanceOf&quot;,...}])<%} else {%>ABI (JSON array, e.g.: [{&quot;name&quot;:&quot;balanceOf&quot;,...}])<%}%>"></textarea>
          </div>
          <div class="form-row" style="margin-top: 8px;">
            <button class="btn btn-secondary" id="btnParseAbi" onclick="parseContractAbi()"><% if (it.locale === 'zh') { %>Ëß£Êûê ABI<% } else { %>Parse ABI<% } %></button>
          </div>
          <div id="abiMethodsContainer" class="hidden" style="margin-top: 12px;">
            <div class="form-row">
              <select class="styled-select" id="abiMethodSelect" onchange="onMethodSelect()">
                <option value=""><% if (it.locale === 'zh') { %>ÈÄâÊã©ÊñπÊ≥ï<% } else { %>Select Method<% } %></option>
              </select>
            </div>
            <div id="methodParamsContainer" style="margin-top: 8px;"></div>
            <div class="form-row" style="margin-top: 12px;">
              <button class="btn btn-secondary" id="btnCallContract" onclick="testCallContract()" disabled><% if (it.locale === 'zh') { %>ËØªÂèñ<% } else { %>Read<% } %></button>
              <button class="btn btn-primary" id="btnSendContract" onclick="testSendContract()" disabled><% if (it.locale === 'zh') { %>ÂÜôÂÖ•<% } else { %>Write<% } %></button>
            </div>
          </div>
        </div>
      </div>

      <div class="result-box">
        <pre id="resultOutput">// <% if (it.locale === 'zh') { %>ÊµãËØïÁªìÊûúÂ∞ÜÊòæÁ§∫Âú®ËøôÈáå<% } else { %>Test results will appear here<% } %></pre>
      </div>
    </div>
  </div>

  <!-- QRCode Library -->
  <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
  <script src="/js/common.js"></script>

  <!-- i18n data (embedded as JSON to avoid script parsing issues) -->
  <script type="application/json" id="i18n-data"><%~ it.translationsJson %></script>

  <script type="module">
    // i18n translations (from server)
    const I18N = JSON.parse(document.getElementById('i18n-data').textContent)
    const LOCALE = '<%= it.locale %>'

    // Translate function
    function t(key, params = {}) {
      let text = I18N[key] || key
      Object.entries(params).forEach(([k, v]) => {
        text = text.replace(new RegExp(`\\{${k}\\}`, 'g'), v)
      })
      return text
    }

    // Theme toggle
    window.toggleTheme = function() {
      ThemeManager.toggle()
      updateThemeIcon()
    }

    function updateThemeIcon() {
      const icon = document.getElementById('themeIcon')
      icon.textContent = ThemeManager.current === 'dark' ? '‚òÄÔ∏è' : 'üåô'
    }

    updateThemeIcon()

    // Set default appUrl to current origin
    document.getElementById('appUrl').value = window.location.origin

    // Language change
    window.changeLang = function(newLang) {
      if (newLang === '<%= it.locale %>') return
      // Set cookie for server-side persistence
      document.cookie = `locale=${newLang};path=/;max-age=31536000;SameSite=Lax`
      localStorage.setItem('locale', newLang)
      // Redirect without lang param (cookie will handle it)
      const url = new URL(window.location.href)
      url.searchParams.delete('lang')
      window.location.href = url.toString()
    }

    // Wallet lang/theme toggle buttons
    window.setWalletLang = function(value) {
      document.getElementById('walletLang').value = value
      document.querySelectorAll('#walletLangGroup .toggle-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.value === value)
      })
    }

    window.setWalletTheme = function(value) {
      document.getElementById('walletTheme').value = value
      document.querySelectorAll('#walletThemeGroup .toggle-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.value === value)
      })
    }

    // Session storage key
    const SESSION_STORAGE_KEY = 'remoteInject_session'

    // Save session to localStorage
    function saveSession(sessionData) {
      try {
        localStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify({
          ...sessionData,
          savedAt: Date.now()
        }))
      } catch (e) {
        console.error('[Demo] Failed to save session:', e)
      }
    }

    // Load session from localStorage
    function loadSession() {
      try {
        const stored = localStorage.getItem(SESSION_STORAGE_KEY)
        if (!stored) return null
        const session = JSON.parse(stored)
        // Session expires after 24 hours
        if (Date.now() - session.savedAt > 24 * 60 * 60 * 1000) {
          clearSession()
          return null
        }
        return session
      } catch (e) {
        console.error('[Demo] Failed to load session:', e)
        return null
      }
    }

    // Clear session from localStorage
    function clearSession() {
      try {
        localStorage.removeItem(SESSION_STORAGE_KEY)
      } catch (e) {
        console.error('[Demo] Failed to clear session:', e)
      }
    }

    // Check if session is still valid on server
    async function checkSessionValid(sessionId) {
      try {
        const res = await fetch(`/session/${sessionId}`)
        if (!res.ok) return false
        const data = await res.json()
        return data.status !== 'expired'
      } catch (e) {
        return false
      }
    }

    // Inline Provider code (simplified for demo)
    class RemoteProvider {
      constructor() {
        this.ws = null
        this.serverUrl = ''
        this.sessionId = ''
        this.sessionUrl = ''
        this.secret = ''  // Store secret for reconnection
        this.requestId = 0
        this.pendingRequests = new Map()
        this.eventListeners = new Map()
        this._chainId = '0x1'
        this._accounts = []
        this._connected = false
        this._userInitiatedDisconnect = false
        this._reconnectAttempts = 0
        this._maxReconnectAttempts = 5
        this._reconnectDelay = 1000

        const events = ['connect', 'disconnect', 'chainChanged', 'accountsChanged', 'message', 'reconnecting']
        events.forEach(event => this.eventListeners.set(event, new Set()))
      }

      async connect(serverUrl, metadata = {}) {
        this.serverUrl = serverUrl.replace(/\/$/, '')
        this._userInitiatedDisconnect = false
        this._reconnectAttempts = 0

        const response = await fetch(`${this.serverUrl}/session`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(metadata),
        })

        if (!response.ok) {
          throw new Error(`Failed to create session: ${response.statusText}`)
        }

        const data = await response.json()
        this.sessionId = data.id
        this.sessionUrl = data.url

        // Extract secret from URL for reconnection
        try {
          const url = new URL(data.url)
          this.secret = url.searchParams.get('k') || ''
        } catch (e) {
          this.secret = ''
        }

        await this.connectWebSocket()

        // Save session for persistence
        saveSession({
          serverUrl: this.serverUrl,
          sessionId: this.sessionId,
          sessionUrl: this.sessionUrl,
          secret: this.secret,
          metadata
        })

        return {
          sessionId: this.sessionId,
          url: this.sessionUrl,
        }
      }

      // Resume an existing session
      async resumeSession(sessionData) {
        this.serverUrl = sessionData.serverUrl
        this.sessionId = sessionData.sessionId
        this.sessionUrl = sessionData.sessionUrl
        this.secret = sessionData.secret || ''
        this._userInitiatedDisconnect = false
        this._reconnectAttempts = 0

        // Verify session is still valid
        const isValid = await checkSessionValid(this.sessionId)
        if (!isValid) {
          clearSession()
          throw new Error('Session expired or invalid')
        }

        await this.connectWebSocket()

        return {
          sessionId: this.sessionId,
          url: this.sessionUrl,
        }
      }

      connectWebSocket() {
        return new Promise((resolve, reject) => {
          const wsUrl = this.serverUrl.replace(/^http/, 'ws')
          this.ws = new WebSocket(`${wsUrl}/ws?session=${this.sessionId}&role=dapp`)

          const timeout = setTimeout(() => {
            reject(new Error('WebSocket connection timeout'))
            this.ws?.close()
          }, 10000)

          this.ws.onopen = () => {
            clearTimeout(timeout)
            this._reconnectAttempts = 0  // Reset on successful connection
          }

          this.ws.onmessage = (event) => {
            this.handleMessage(event.data)
            try {
              const msg = JSON.parse(event.data)
              if (msg.type === 'ready') {
                resolve()
              }
            } catch {}
          }

          this.ws.onclose = (event) => {
            this._connected = false

            // Don't reconnect if user initiated disconnect
            if (this._userInitiatedDisconnect) {
              this.emit('disconnect', { code: 4900, message: 'User disconnected', userInitiated: true })
              return
            }

            // Try to reconnect for non-user-initiated disconnects
            if (this._reconnectAttempts < this._maxReconnectAttempts) {
              this._reconnectAttempts++
              const delay = this._reconnectDelay * Math.pow(1.5, this._reconnectAttempts - 1)
              console.log(`[RemoteProvider] Connection lost, reconnecting in ${delay}ms (attempt ${this._reconnectAttempts}/${this._maxReconnectAttempts})`)

              this.emit('reconnecting', { attempt: this._reconnectAttempts, maxAttempts: this._maxReconnectAttempts })

              setTimeout(() => {
                if (!this._userInitiatedDisconnect) {
                  this.connectWebSocket().catch(err => {
                    console.error('[RemoteProvider] Reconnect failed:', err)
                  })
                }
              }, delay)
            } else {
              this.emit('disconnect', { code: 4900, message: 'Connection lost', userInitiated: false })
            }
          }

          this.ws.onerror = (error) => {
            clearTimeout(timeout)
            reject(new Error('WebSocket connection failed'))
          }
        })
      }

      handleMessage(data) {
        try {
          const message = JSON.parse(data)

          switch (message.type) {
            case 'ready':
              break

            case 'connect':
              this._connected = true
              this._accounts = [message.address]
              this._chainId = '0x' + message.chainId.toString(16)
              this.emit('connect', { chainId: this._chainId })
              this.emit('accountsChanged', this._accounts)
              break

            case 'disconnect':
              this._connected = false
              this._accounts = []
              this.emit('disconnect', { code: 4900, message: message.reason || 'Disconnected' })
              break

            case 'response':
              this.handleResponse(message)
              break

            case 'chainChanged':
              this._chainId = '0x' + message.chainId.toString(16)
              this.emit('chainChanged', this._chainId)
              break

            case 'accountsChanged':
              this._accounts = message.accounts
              this.emit('accountsChanged', this._accounts)
              if (message.accounts.length === 0) {
                this._connected = false
                this.emit('disconnect', { code: 4900, message: 'Wallet disconnected' })
              }
              break

            case 'error':
              console.error('[RemoteProvider] Server error:', message)
              break
          }
        } catch (error) {
          console.error('[RemoteProvider] Failed to parse message:', error)
        }
      }

      handleResponse(message) {
        const pending = this.pendingRequests.get(message.id)
        if (!pending) return

        clearTimeout(pending.timeout)
        this.pendingRequests.delete(message.id)

        if (message.error) {
          const error = new Error(message.error.message)
          error.code = message.error.code
          pending.reject(error)
        } else {
          pending.resolve(message.result)
        }
      }

      async request(args) {
        const { method, params } = args

        switch (method) {
          case 'eth_accounts':
            return this._accounts

          case 'eth_chainId':
            return this._chainId

          case 'eth_requestAccounts':
            if (this._connected && this._accounts.length > 0) {
              return this._accounts
            }
            return new Promise((resolve, reject) => {
              const timeout = setTimeout(() => {
                reject({ code: 4001, message: 'User rejected the request' })
              }, 60000)

              const handler = (accounts) => {
                clearTimeout(timeout)
                this.removeListener('accountsChanged', handler)
                resolve(accounts)
              }

              this.on('accountsChanged', handler)
            })
        }

        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
          throw { code: -32000, message: 'Not connected' }
        }

        if (!this._connected) {
          throw { code: -32000, message: 'Mobile wallet not connected' }
        }

        return this.sendRequest(method, params)
      }

      sendRequest(method, params) {
        return new Promise((resolve, reject) => {
          const id = ++this.requestId

          const timeout = setTimeout(() => {
            this.pendingRequests.delete(id)
            reject({ code: -32003, message: 'Request timeout' })
          }, 60000)

          this.pendingRequests.set(id, { resolve, reject, timeout })

          this.ws.send(JSON.stringify({
            type: 'request',
            id,
            method,
            params: params || [],
          }))
        })
      }

      on(event, listener) {
        this.eventListeners.get(event)?.add(listener)
      }

      removeListener(event, listener) {
        this.eventListeners.get(event)?.delete(listener)
      }

      emit(event, ...args) {
        this.eventListeners.get(event)?.forEach(listener => {
          try {
            listener(...args)
          } catch (error) {
            console.error(`[RemoteProvider] Event listener error:`, error)
          }
        })
      }

      disconnect() {
        this._userInitiatedDisconnect = true  // Mark as user-initiated
        if (this.ws) {
          try {
            this.ws.send(JSON.stringify({ type: 'disconnect', reason: 'User initiated' }))
          } catch (e) {}
          this.ws.close()
          this.ws = null
        }
        this._connected = false
        this._accounts = []
        clearSession()  // Clear stored session on user disconnect
      }

      get isConnected() {
        return this._connected
      }

      get accounts() {
        return this._accounts
      }

      get chainId() {
        return this._chainId
      }

      get session() {
        return {
          id: this.sessionId,
          url: this.sessionUrl,
        }
      }
    }

    // Global variables
    let provider = null
    let currentAccount = null  // Currently selected account for operations

    // Get current account (selected or first available)
    function getCurrentAccount() {
      return currentAccount || (provider?.accounts?.[0] ?? null)
    }

    // Update account list with all available accounts
    function updateAccountSelector(accounts) {
      const listEl = document.getElementById('accountList')
      const countSpan = document.getElementById('accountCount')

      if (!listEl) return

      // Clear existing items
      listEl.innerHTML = ''

      if (!accounts || accounts.length === 0) {
        listEl.innerHTML = '<div class="account-item" data-empty>-</div>'
        if (countSpan) countSpan.textContent = ''
        return
      }

      // Add all accounts as clickable items
      accounts.forEach((account, index) => {
        const item = document.createElement('div')
        item.className = 'account-item'
        item.dataset.address = account
        const abbrev = account.slice(0, 8) + '...' + account.slice(-6)
        item.textContent = accounts.length > 1 ? `[${index + 1}] ${abbrev}` : abbrev
        item.title = account  // Full address on hover
        item.onclick = () => onAccountSelect(account)
        listEl.appendChild(item)
      })

      // Show account count
      if (countSpan) {
        countSpan.textContent = `(${accounts.length})`
      }

      // Set current selection
      if (currentAccount && accounts.includes(currentAccount)) {
        setActiveAccount(currentAccount)
      } else {
        currentAccount = accounts[0]
        setActiveAccount(currentAccount)
      }
    }

    // Set visual active state for account
    function setActiveAccount(address) {
      document.querySelectorAll('.account-item').forEach(item => {
        item.classList.toggle('active', item.dataset.address === address)
      })
    }

    // Handle account selection change
    function onAccountSelect(address) {
      if (!address) return
      currentAccount = address
      setActiveAccount(address)
      const abbrev = address.slice(0, 8) + '...' + address.slice(-6)
      logResult(LOCALE === 'zh' ? `Â∑≤ÂàáÊç¢Âà∞Ë¥¶Êà∑: ${abbrev}` : `Switched to account: ${abbrev}`, 'info')

      // Notify bridge about account switch
      if (provider && provider.ws && provider.ws.readyState === WebSocket.OPEN) {
        provider.ws.send(JSON.stringify({
          type: 'accountSwitch',
          address: address
        }))
      }
    }

    // Selected chain for switching
    let selectedChainId = '0x1'

    // Initialize chain chip click handlers
    function initChainChips() {
      document.querySelectorAll('.chain-chip').forEach(chip => {
        chip.onclick = () => selectChain(chip.dataset.chain)
      })
    }

    // Select a chain chip and trigger switch
    function selectChain(chainId) {
      if (!provider || !provider.isConnected) return

      selectedChainId = chainId

      // If clicking current chain, do nothing
      const currentChainId = provider.chainId?.toLowerCase()
      if (chainId.toLowerCase() === currentChainId) {
        logResult(LOCALE === 'zh' ? `Â∑≤Âú®Ê≠§Èìæ‰∏ä` : `Already on this chain`, 'info')
        return
      }

      // Trigger switch
      testSwitchChain()
    }

    // Update current chain indicator (normalize chainId format)
    function updateCurrentChain(chainId) {
      const normalizedChainId = chainId?.toLowerCase()
      console.log('[Demo] updateCurrentChain:', chainId, 'normalized:', normalizedChainId)

      document.querySelectorAll('.chain-chip').forEach(chip => {
        const chipChainId = chip.dataset.chain?.toLowerCase()
        const isCurrent = chipChainId === normalizedChainId
        chip.classList.toggle('current', isCurrent)
      })
    }

    // Initialize on load
    initChainChips()

    // Try to fetch all authorized accounts using wallet_getPermissions
    async function fetchAllAuthorizedAccounts() {
      if (!provider || !provider.isConnected) return

      try {
        const permissions = await provider.request({ method: 'wallet_getPermissions' })
        const ethAccountsPermission = permissions.find(p => p.parentCapability === 'eth_accounts')

        if (ethAccountsPermission?.caveats) {
          const caveat = ethAccountsPermission.caveats.find(c => c.type === 'restrictReturnedAccounts')
          if (caveat?.value && Array.isArray(caveat.value) && caveat.value.length > 0) {
            logResult(LOCALE === 'zh' ? `Ëé∑ÂèñÂà∞ ${caveat.value.length} ‰∏™ÊéàÊùÉË¥¶Êà∑` : `Found ${caveat.value.length} authorized accounts`, 'info')
            updateAccountSelector(caveat.value)
            return caveat.value
          }
        }
      } catch (error) {
        // wallet_getPermissions not supported, use default accounts
        console.log('[Demo] wallet_getPermissions not supported:', error.message)
      }
      return null
    }

    // Update status display
    function updateStatus(status, text) {
      const badge = document.getElementById('statusBadge')
      const statusText = document.getElementById('statusText')

      badge.className = `status-badge ${status}`
      statusText.textContent = text

      const buttons = [
        'btnAccounts', 'btnChainId', 'btnBalance', 'btnSign', 'btnSend',
        'btnRequestAccounts', 'btnSignTypedData',
        'btnReadContract', 'btnEstimateGas', 'btnBlockNumber',
        'btnCustomTransfer'
      ]
      buttons.forEach(id => {
        const el = document.getElementById(id)
        if (el) el.disabled = status !== 'connected'
      })

      // Enable/disable chain chips
      document.querySelectorAll('.chain-chip').forEach(chip => {
        chip.disabled = status !== 'connected'
      })

      // Enable/disable contract call buttons based on selected method
      if (selectedMethod) {
        const isView = selectedMethod.stateMutability === 'view' || selectedMethod.stateMutability === 'pure' || selectedMethod.constant
        document.getElementById('btnCallContract').disabled = status !== 'connected'
        document.getElementById('btnSendContract').disabled = status !== 'connected' || isView
      } else {
        document.getElementById('btnCallContract').disabled = true
        document.getElementById('btnSendContract').disabled = true
      }

      document.getElementById('walletInfo').style.display = status === 'connected' ? 'block' : 'none'
    }

    // Safe: escape HTML special characters
    function escapeHtml(str) {
      if (!str) return ''
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;')
    }

    // Log result (safe: escape message content)
    function logResult(message, type = 'default') {
      const output = document.getElementById('resultOutput')
      const timestamp = new Date().toLocaleTimeString()
      const className = type === 'error' ? 'error' : type === 'info' ? 'info' : ''
      const escapedMessage = escapeHtml(message)
      output.innerHTML = `<span class="${className}">[${timestamp}] ${escapedMessage}</span>\n` + output.innerHTML
    }

    // Start connect
    window.startConnect = async function() {
      try {
        // Clear any existing session when starting new connection
        clearSession()
        document.getElementById('resumeBtn')?.remove()

        document.getElementById('connectBtn').disabled = true
        updateStatus('connecting', t('demo.waitingConnection'))
        logResult(LOCALE === 'zh' ? 'ÂàõÂª∫ Session...' : 'Creating session...', 'info')

        provider = new RemoteProvider()

        // Listen for events
        provider.on('connect', async (info) => {
          logResult(LOCALE === 'zh' ? `Â∑≤ËøûÊé•ÔºåÈìæ ID: ${info.chainId}` : `Connected, Chain ID: ${info.chainId}`, 'info')
          updateStatus('connected', t('bridge.connected'))

          document.getElementById('walletChainId').textContent = provider.chainId
          document.getElementById('walletSession').textContent = provider.session.id
          updateCurrentChain(provider.chainId)

          // Always show the account from connect message first
          console.log('[Demo] provider.accounts:', provider.accounts)
          if (provider.accounts && provider.accounts.length > 0) {
            updateAccountSelector(provider.accounts)
          }

          // Then try to get all authorized accounts
          const allAccounts = await fetchAllAuthorizedAccounts()
          if (allAccounts && allAccounts.length > 0) {
            updateAccountSelector(allAccounts)
          }
        })

        provider.on('disconnect', (info) => {
          logResult(LOCALE === 'zh' ? `Â∑≤Êñ≠ÂºÄ: ${info.message}` : `Disconnected: ${info.message}`, 'error')
          updateStatus('disconnected', t('demo.notConnected'))

          // Only show connect button if user initiated or max reconnects reached
          if (info.userInitiated || !provider || provider._reconnectAttempts >= provider._maxReconnectAttempts) {
            document.getElementById('connectBtn').classList.remove('hidden')
            document.getElementById('disconnectBtn').classList.add('hidden')
            document.getElementById('connectBtn').disabled = false
            document.getElementById('qrcode').innerHTML = ''
            document.getElementById('sessionUrl').textContent = ''
            document.getElementById('qrContainer').classList.add('hidden')
            document.getElementById('configSection').classList.remove('hidden')
          }
        })

        provider.on('reconnecting', (info) => {
          logResult(LOCALE === 'zh' ? `Ê≠£Âú®ÈáçËøû... (${info.attempt}/${info.maxAttempts})` : `Reconnecting... (${info.attempt}/${info.maxAttempts})`, 'info')
          updateStatus('connecting', LOCALE === 'zh' ? 'ÈáçÊñ∞ËøûÊé•‰∏≠...' : 'Reconnecting...')
        })

        provider.on('chainChanged', (chainId) => {
          logResult(LOCALE === 'zh' ? `ÈìæÂ∑≤ÂàáÊç¢: ${chainId}` : `Chain changed: ${chainId}`, 'info')
          document.getElementById('walletChainId').textContent = chainId
          updateCurrentChain(chainId)
        })

        provider.on('accountsChanged', (accounts) => {
          if (accounts.length > 0) {
            logResult(LOCALE === 'zh' ? `Ë¥¶Êà∑Â∑≤Êõ¥Êñ∞ÔºåÂÖ± ${accounts.length} ‰∏™Ë¥¶Êà∑` : `Accounts updated, ${accounts.length} account(s)`, 'info')
            updateAccountSelector(accounts)
          }
        })

        // Connect to server (pass DApp metadata from config)
        const serverUrl = window.location.origin
        const appName = document.getElementById('appName').value.trim() || 'Remote Inject Demo'
        const appUrl = document.getElementById('appUrl').value.trim() || window.location.origin
        const appIcon = document.getElementById('appIcon').value.trim() || undefined

        const { sessionId, url } = await provider.connect(serverUrl, {
          name: appName,
          url: appUrl,
          icon: appIcon,
        })

        // Show cancel button and QR area, hide config
        document.getElementById('connectBtn').classList.add('hidden')
        document.getElementById('disconnectBtn').classList.remove('hidden')
        document.getElementById('configSection').classList.add('hidden')
        document.getElementById('qrContainer').classList.remove('hidden')

        logResult(LOCALE === 'zh' ? `Session Â∑≤ÂàõÂª∫: ${sessionId}` : `Session created: ${sessionId}`, 'info')
        logResult(LOCALE === 'zh' ? 'Á≠âÂæÖÁßªÂä®Èí±ÂåÖÊâ´Á†Å...' : 'Waiting for mobile wallet to scan...', 'info')

        // Append lang/theme options to URL
        let finalUrl = url
        const walletLang = document.getElementById('walletLang').value
        const walletTheme = document.getElementById('walletTheme').value
        const urlObj = new URL(finalUrl)
        if (walletLang) urlObj.searchParams.set('lang', walletLang)
        if (walletTheme) urlObj.searchParams.set('theme', walletTheme)
        finalUrl = urlObj.toString()

        // Show QR code and link
        document.getElementById('sessionUrl').textContent = finalUrl
        const qrcodeContainer = document.getElementById('qrcode')
        qrcodeContainer.innerHTML = ''
        new QRCode(qrcodeContainer, {
          text: finalUrl,
          width: 220,
          height: 220,
          colorDark: '#1a1a2e',
          colorLight: '#ffffff',
          correctLevel: QRCode.CorrectLevel.M
        })

      } catch (error) {
        logResult(LOCALE === 'zh' ? `ËøûÊé•Â§±Ë¥•: ${error.message}` : `Connection failed: ${error.message}`, 'error')
        updateStatus('disconnected', t('demo.notConnected'))
        document.getElementById('connectBtn').disabled = false
      }
    }

    // Disconnect
    window.disconnect = function() {
      if (provider) {
        provider.disconnect()
        provider = null
      }
      document.getElementById('qrcode').innerHTML = ''
      document.getElementById('sessionUrl').textContent = ''
      document.getElementById('qrContainer').classList.add('hidden')
      document.getElementById('configSection').classList.remove('hidden')
      updateStatus('disconnected', t('demo.notConnected'))
      document.getElementById('connectBtn').classList.remove('hidden')
      document.getElementById('disconnectBtn').classList.add('hidden')
      document.getElementById('connectBtn').disabled = false
    }

    // Resume existing session
    window.resumeSession = async function() {
      const sessionData = loadSession()
      if (!sessionData) {
        logResult(LOCALE === 'zh' ? 'Ê≤°ÊúâÂèØÊÅ¢Â§çÁöÑ‰ºöËØù' : 'No session to resume', 'error')
        return
      }

      try {
        document.getElementById('connectBtn').disabled = true
        document.getElementById('resumeBtn')?.remove()
        updateStatus('connecting', LOCALE === 'zh' ? 'ÊÅ¢Â§çËøûÊé•‰∏≠...' : 'Resuming connection...')
        logResult(LOCALE === 'zh' ? `ÊÅ¢Â§ç Session: ${sessionData.sessionId}` : `Resuming session: ${sessionData.sessionId}`, 'info')

        provider = new RemoteProvider()

        // Listen for events (same as startConnect)
        provider.on('connect', async (info) => {
          logResult(LOCALE === 'zh' ? `Â∑≤ËøûÊé•ÔºåÈìæ ID: ${info.chainId}` : `Connected, Chain ID: ${info.chainId}`, 'info')
          updateStatus('connected', t('bridge.connected'))

          document.getElementById('walletChainId').textContent = provider.chainId
          document.getElementById('walletSession').textContent = provider.session.id
          updateCurrentChain(provider.chainId)

          // Always show the account from connect message first
          if (provider.accounts && provider.accounts.length > 0) {
            updateAccountSelector(provider.accounts)
          }

          // Then try to get all authorized accounts
          const allAccounts = await fetchAllAuthorizedAccounts()
          if (allAccounts && allAccounts.length > 0) {
            updateAccountSelector(allAccounts)
          }
        })

        provider.on('disconnect', (info) => {
          logResult(LOCALE === 'zh' ? `Â∑≤Êñ≠ÂºÄ: ${info.message}` : `Disconnected: ${info.message}`, 'error')
          updateStatus('disconnected', t('demo.notConnected'))

          if (info.userInitiated || !provider || provider._reconnectAttempts >= provider._maxReconnectAttempts) {
            document.getElementById('connectBtn').classList.remove('hidden')
            document.getElementById('disconnectBtn').classList.add('hidden')
            document.getElementById('connectBtn').disabled = false
            document.getElementById('qrcode').innerHTML = ''
            document.getElementById('sessionUrl').textContent = ''
            document.getElementById('qrContainer').classList.add('hidden')
            document.getElementById('configSection').classList.remove('hidden')
          }
        })

        provider.on('reconnecting', (info) => {
          logResult(LOCALE === 'zh' ? `Ê≠£Âú®ÈáçËøû... (${info.attempt}/${info.maxAttempts})` : `Reconnecting... (${info.attempt}/${info.maxAttempts})`, 'info')
          updateStatus('connecting', LOCALE === 'zh' ? 'ÈáçÊñ∞ËøûÊé•‰∏≠...' : 'Reconnecting...')
        })

        provider.on('chainChanged', (chainId) => {
          logResult(LOCALE === 'zh' ? `ÈìæÂ∑≤ÂàáÊç¢: ${chainId}` : `Chain changed: ${chainId}`, 'info')
          document.getElementById('walletChainId').textContent = chainId
          updateCurrentChain(chainId)
        })

        provider.on('accountsChanged', (accounts) => {
          if (accounts.length > 0) {
            logResult(LOCALE === 'zh' ? `Ë¥¶Êà∑Â∑≤Êõ¥Êñ∞ÔºåÂÖ± ${accounts.length} ‰∏™Ë¥¶Êà∑` : `Accounts updated, ${accounts.length} account(s)`, 'info')
            updateAccountSelector(accounts)
          }
        })

        await provider.resumeSession(sessionData)

        // Show QR area, hide config
        document.getElementById('connectBtn').classList.add('hidden')
        document.getElementById('disconnectBtn').classList.remove('hidden')
        document.getElementById('configSection').classList.add('hidden')
        document.getElementById('qrContainer').classList.remove('hidden')

        // Show QR code and link
        let finalUrl = sessionData.sessionUrl
        const walletLang = document.getElementById('walletLang').value
        const walletTheme = document.getElementById('walletTheme').value
        const urlObj = new URL(finalUrl)
        if (walletLang) urlObj.searchParams.set('lang', walletLang)
        if (walletTheme) urlObj.searchParams.set('theme', walletTheme)
        finalUrl = urlObj.toString()

        document.getElementById('sessionUrl').textContent = finalUrl
        const qrcodeContainer = document.getElementById('qrcode')
        qrcodeContainer.innerHTML = ''
        new QRCode(qrcodeContainer, {
          text: finalUrl,
          width: 220,
          height: 220,
          colorDark: '#1a1a2e',
          colorLight: '#ffffff',
          correctLevel: QRCode.CorrectLevel.M
        })

        logResult(LOCALE === 'zh' ? 'Á≠âÂæÖÁßªÂä®Èí±ÂåÖÈáçÊñ∞ËøûÊé•...' : 'Waiting for mobile wallet to reconnect...', 'info')

      } catch (error) {
        logResult(LOCALE === 'zh' ? `ÊÅ¢Â§çÂ§±Ë¥•: ${error.message}` : `Resume failed: ${error.message}`, 'error')
        updateStatus('disconnected', t('demo.notConnected'))
        document.getElementById('connectBtn').disabled = false
        clearSession()
      }
    }

    // Check for existing session on page load
    ;(async function checkExistingSession() {
      const sessionData = loadSession()
      if (sessionData) {
        const isValid = await checkSessionValid(sessionData.sessionId)
        if (isValid) {
          logResult(LOCALE === 'zh' ? `ÂèëÁé∞Êú™ÂÆåÊàêÁöÑ‰ºöËØù: ${sessionData.sessionId}` : `Found existing session: ${sessionData.sessionId}`, 'info')

          // Add resume button
          const connectBtn = document.getElementById('connectBtn')
          const resumeBtn = document.createElement('button')
          resumeBtn.id = 'resumeBtn'
          resumeBtn.className = 'btn btn-secondary'
          resumeBtn.textContent = LOCALE === 'zh' ? 'ÊÅ¢Â§çËøûÊé•' : 'Resume'
          resumeBtn.onclick = resumeSession
          connectBtn.parentNode.insertBefore(resumeBtn, connectBtn)

          // Update connect button text
          connectBtn.textContent = LOCALE === 'zh' ? 'Êñ∞Âª∫ËøûÊé•' : 'New Session'
        } else {
          clearSession()
        }
      }
    })()

    // Copy link
    window.copySessionUrl = async function() {
      const url = document.getElementById('sessionUrl').textContent
      if (!url) return

      try {
        await navigator.clipboard.writeText(url)
        const btn = document.getElementById('copyBtn')
        btn.textContent = t('common.copied')
        btn.classList.add('copied')
        setTimeout(() => {
          btn.textContent = t('common.copy')
          btn.classList.remove('copied')
        }, 2000)
        logResult(LOCALE === 'zh' ? 'ÈìæÊé•Â∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø' : 'Link copied to clipboard', 'info')
      } catch (error) {
        logResult(LOCALE === 'zh' ? 'Â§çÂà∂Â§±Ë¥•: ' + error.message : 'Copy failed: ' + error.message, 'error')
      }
    }

    // Test: get accounts - tries wallet_getPermissions first for all authorized accounts
    window.testGetAccounts = async function() {
      try {
        // First try wallet_getPermissions to get ALL authorized accounts
        logResult(LOCALE === 'zh' ? 'Ë∞ÉÁî® wallet_getPermissions Ëé∑ÂèñÊâÄÊúâÊéàÊùÉË¥¶Êà∑...' : 'Calling wallet_getPermissions to get all authorized accounts...', 'info')

        try {
          const permissions = await provider.request({ method: 'wallet_getPermissions' })
          const ethAccountsPermission = permissions.find(p => p.parentCapability === 'eth_accounts')

          if (ethAccountsPermission?.caveats) {
            const caveat = ethAccountsPermission.caveats.find(c => c.type === 'restrictReturnedAccounts')
            if (caveat?.value && Array.isArray(caveat.value)) {
              const allAccounts = caveat.value
              logResult(LOCALE === 'zh' ? `ÊâÄÊúâÊéàÊùÉË¥¶Êà∑ (${allAccounts.length}): ${JSON.stringify(allAccounts)}` : `All authorized accounts (${allAccounts.length}): ${JSON.stringify(allAccounts)}`)
              // Update the account selector with all accounts
              updateAccountSelector(allAccounts)
              return
            }
          }
        } catch (permError) {
          logResult(LOCALE === 'zh' ? `wallet_getPermissions ‰∏çÊîØÊåÅÔºåÂõûÈÄÄÂà∞ eth_accounts` : `wallet_getPermissions not supported, falling back to eth_accounts`, 'info')
        }

        // Fallback to eth_accounts (only returns current account)
        const accounts = await provider.request({ method: 'eth_accounts' })
        logResult(LOCALE === 'zh' ? `ÂΩìÂâçË¥¶Êà∑: ${JSON.stringify(accounts)}` : `Current accounts: ${JSON.stringify(accounts)}`)
      } catch (error) {
        logResult(LOCALE === 'zh' ? `ÈîôËØØ: ${error.message}` : `Error: ${error.message}`, 'error')
      }
    }

    // Test: get chain ID
    window.testGetChainId = async function() {
      try {
        logResult(LOCALE === 'zh' ? 'Ë∞ÉÁî® eth_chainId...' : 'Calling eth_chainId...', 'info')
        const chainId = await provider.request({ method: 'eth_chainId' })
        logResult(LOCALE === 'zh' ? `Èìæ ID: ${chainId} (${parseInt(chainId, 16)})` : `Chain ID: ${chainId} (${parseInt(chainId, 16)})`)
      } catch (error) {
        logResult(LOCALE === 'zh' ? `ÈîôËØØ: ${error.message}` : `Error: ${error.message}`, 'error')
      }
    }

    // Test: get balance
    window.testGetBalance = async function() {
      try {
        const account = getCurrentAccount()
        logResult(LOCALE === 'zh' ? `Ë∞ÉÁî® eth_getBalance (${account.slice(0,8)}...)...` : `Calling eth_getBalance (${account.slice(0,8)}...)...`, 'info')
        const balance = await provider.request({
          method: 'eth_getBalance',
          params: [account, 'latest'],
        })
        const eth = parseInt(balance, 16) / 1e18
        logResult(LOCALE === 'zh' ? `‰ΩôÈ¢ù: ${balance} (${eth.toFixed(6)} ETH)` : `Balance: ${balance} (${eth.toFixed(6)} ETH)`)
      } catch (error) {
        logResult(LOCALE === 'zh' ? `ÈîôËØØ: ${error.message}` : `Error: ${error.message}`, 'error')
      }
    }

    // Test: sign message
    window.testPersonalSign = async function() {
      try {
        const account = getCurrentAccount()
        const message = 'Hello from Remote Inject! ' + new Date().toISOString()
        logResult(LOCALE === 'zh' ? `Ë∞ÉÁî® personal_sign: "${message}"` : `Calling personal_sign: "${message}"`, 'info')

        const signature = await provider.request({
          method: 'personal_sign',
          params: [
            '0x' + Array.from(new TextEncoder().encode(message)).map(b => b.toString(16).padStart(2, '0')).join(''),
            account,
          ],
        })
        logResult(LOCALE === 'zh' ? `Á≠æÂêç: ${signature}` : `Signature: ${signature}`)
      } catch (error) {
        logResult(LOCALE === 'zh' ? `ÈîôËØØ: ${error.message}` : `Error: ${error.message}`, 'error')
      }
    }

    // Test: send transaction
    window.testSendTransaction = async function() {
      try {
        const account = getCurrentAccount()
        logResult(LOCALE === 'zh' ? 'Ë∞ÉÁî® eth_sendTransaction (ÂèëÈÄÅ 0 ETH Âà∞Ëá™Â∑±)...' : 'Calling eth_sendTransaction (sending 0 ETH to self)...', 'info')

        const txHash = await provider.request({
          method: 'eth_sendTransaction',
          params: [{
            from: account,
            to: account,
            value: '0x0',
          }],
        })
        logResult(LOCALE === 'zh' ? `‰∫§ÊòìÂìàÂ∏å: ${txHash}` : `Transaction hash: ${txHash}`)
      } catch (error) {
        logResult(LOCALE === 'zh' ? `ÈîôËØØ: ${error.message}` : `Error: ${error.message}`, 'error')
      }
    }

    // Chain names mapping
    const CHAIN_NAMES = {
      '0x1': 'Ethereum',
      '0x89': 'Polygon',
      '0xa4b1': 'Arbitrum',
      '0xa': 'Optimism',
      '0x38': 'BSC',
      '0xa86a': 'Avalanche',
      '0x2105': 'Base',
      '0xaa36a7': 'Sepolia',
    }

    // Test: switch chain
    window.testSwitchChain = async function() {
      try {
        const targetChainId = selectedChainId
        const chainName = CHAIN_NAMES[targetChainId] || targetChainId

        // Skip if already on this chain
        if (provider.chainId === targetChainId) {
          logResult(LOCALE === 'zh' ? `Â∑≤Âú® ${chainName} Èìæ‰∏ä` : `Already on ${chainName}`, 'info')
          return
        }

        logResult(LOCALE === 'zh' ? `Ë∞ÉÁî® wallet_switchEthereumChain: ${chainName}...` : `Calling wallet_switchEthereumChain: ${chainName}...`, 'info')

        await provider.request({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: targetChainId }],
        })
        logResult(LOCALE === 'zh' ? `Â∑≤ÂàáÊç¢Âà∞: ${chainName}` : `Switched to: ${chainName}`)
      } catch (error) {
        // Error 4902 means chain not added, try to add it
        if (error.code === 4902) {
          logResult(LOCALE === 'zh' ? 'Èí±ÂåÖ‰∏≠Êú™Ê∑ªÂä†Ê≠§ÈìæÔºåËØ∑ÂÖàÂú®Èí±ÂåÖ‰∏≠Ê∑ªÂä†' : 'Chain not added in wallet, please add it first', 'error')
        } else {
          logResult(LOCALE === 'zh' ? `ÈîôËØØ: ${error.message}` : `Error: ${error.message}`, 'error')
        }
      }
    }

    // Test: request accounts (re-request authorization)
    window.testRequestAccounts = async function() {
      try {
        logResult(LOCALE === 'zh' ? 'Ë∞ÉÁî® eth_requestAccounts...' : 'Calling eth_requestAccounts...', 'info')
        const accounts = await provider.request({ method: 'eth_requestAccounts' })
        logResult(LOCALE === 'zh' ? `ÊéàÊùÉË¥¶Êà∑: ${JSON.stringify(accounts)}` : `Authorized accounts: ${JSON.stringify(accounts)}`)
      } catch (error) {
        logResult(LOCALE === 'zh' ? `ÈîôËØØ: ${error.message}` : `Error: ${error.message}`, 'error')
      }
    }

    // Test: EIP-712 typed data signature
    window.testSignTypedData = async function() {
      try {
        const account = getCurrentAccount()
        const chainId = parseInt(provider.chainId, 16)
        const typedData = {
          types: {
            EIP712Domain: [
              { name: 'name', type: 'string' },
              { name: 'version', type: 'string' },
              { name: 'chainId', type: 'uint256' },
              { name: 'verifyingContract', type: 'address' },
            ],
            Person: [
              { name: 'name', type: 'string' },
              { name: 'wallet', type: 'address' },
            ],
            Mail: [
              { name: 'from', type: 'Person' },
              { name: 'to', type: 'Person' },
              { name: 'contents', type: 'string' },
            ],
          },
          primaryType: 'Mail',
          domain: {
            name: 'Remote Inject Demo',
            version: '1',
            chainId: chainId,
            verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
          },
          message: {
            from: {
              name: 'Alice',
              wallet: account,
            },
            to: {
              name: 'Bob',
              wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
            },
            contents: 'Hello, Bob! Time: ' + new Date().toISOString(),
          },
        }

        logResult(LOCALE === 'zh' ? 'Ë∞ÉÁî® eth_signTypedData_v4 (EIP-712)...' : 'Calling eth_signTypedData_v4 (EIP-712)...', 'info')

        const signature = await provider.request({
          method: 'eth_signTypedData_v4',
          params: [account, JSON.stringify(typedData)],
        })
        logResult(LOCALE === 'zh' ? `EIP-712 Á≠æÂêç: ${signature}` : `EIP-712 Signature: ${signature}`)
      } catch (error) {
        logResult(LOCALE === 'zh' ? `ÈîôËØØ: ${error.message}` : `Error: ${error.message}`, 'error')
      }
    }

    // Test: get block number
    window.testGetBlockNumber = async function() {
      try {
        logResult(LOCALE === 'zh' ? 'Ë∞ÉÁî® eth_blockNumber...' : 'Calling eth_blockNumber...', 'info')
        const blockNumber = await provider.request({ method: 'eth_blockNumber' })
        logResult(LOCALE === 'zh' ? `Âå∫ÂùóÈ´òÂ∫¶: ${blockNumber} (${parseInt(blockNumber, 16)})` : `Block number: ${blockNumber} (${parseInt(blockNumber, 16)})`)
      } catch (error) {
        logResult(LOCALE === 'zh' ? `ÈîôËØØ: ${error.message}` : `Error: ${error.message}`, 'error')
      }
    }

    // Test: read contract (eth_call) - read USDC decimals on current chain
    window.testReadContract = async function() {
      try {
        // Common USDC contract addresses on different chains
        const usdcAddresses = {
          '0x1': '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', // Ethereum
          '0x89': '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174', // Polygon
          '0xa4b1': '0xaf88d065e77c8cC2239327C5EDb3A432268e5831', // Arbitrum
          '0xa': '0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85', // Optimism
          '0x38': '0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d', // BSC
          '0xa86a': '0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E', // Avalanche
          '0x2105': '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', // Base
        }

        const chainId = provider.chainId
        const usdcAddress = usdcAddresses[chainId]

        if (!usdcAddress) {
          logResult(LOCALE === 'zh' ? `ÂΩìÂâçÈìæ (${chainId}) Êó†È¢ÑËÆæ USDC ÂêàÁ∫¶Âú∞ÂùÄÔºå‰ΩøÁî® ETH name() Ë∞ÉÁî®Á§∫‰æã` : `Current chain (${chainId}) has no preset USDC address, using ETH name() call example`, 'info')
          // Try calling a simple function - name() on WETH (most chains have it)
          return
        }

        // decimals() function selector: 0x313ce567
        const data = '0x313ce567'

        logResult(LOCALE === 'zh' ? `Ë∞ÉÁî® eth_call: USDC decimals() on ${chainId}...` : `Calling eth_call: USDC decimals() on ${chainId}...`, 'info')

        const result = await provider.request({
          method: 'eth_call',
          params: [{
            to: usdcAddress,
            data: data,
          }, 'latest'],
        })

        const decimals = parseInt(result, 16)
        logResult(LOCALE === 'zh' ? `USDC decimals: ${decimals}` : `USDC decimals: ${decimals}`)
      } catch (error) {
        logResult(LOCALE === 'zh' ? `ÈîôËØØ: ${error.message}` : `Error: ${error.message}`, 'error')
      }
    }

    // Test: estimate gas
    window.testEstimateGas = async function() {
      try {
        const account = getCurrentAccount()
        logResult(LOCALE === 'zh' ? 'Ë∞ÉÁî® eth_estimateGas (‰º∞ÁÆóÂèëÈÄÅ 0 ETH)...' : 'Calling eth_estimateGas (estimate sending 0 ETH)...', 'info')

        const gasEstimate = await provider.request({
          method: 'eth_estimateGas',
          params: [{
            from: account,
            to: account,
            value: '0x0',
          }],
        })

        const gasNumber = parseInt(gasEstimate, 16)
        logResult(LOCALE === 'zh' ? `Gas ‰º∞ÁÆó: ${gasEstimate} (${gasNumber})` : `Gas estimate: ${gasEstimate} (${gasNumber})`)
      } catch (error) {
        logResult(LOCALE === 'zh' ? `ÈîôËØØ: ${error.message}` : `Error: ${error.message}`, 'error')
      }
    }

    // ==================== Custom Transfer ====================

    // Test: custom transfer
    window.testCustomTransfer = async function() {
      try {
        const account = getCurrentAccount()
        const toAddress = document.getElementById('transferTo').value.trim()
        const amountStr = document.getElementById('transferAmount').value.trim()

        if (!toAddress || !toAddress.match(/^0x[a-fA-F0-9]{40}$/)) {
          logResult(LOCALE === 'zh' ? 'ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑÊé•Êî∂Âú∞ÂùÄ' : 'Please enter a valid recipient address', 'error')
          return
        }

        if (!amountStr || isNaN(parseFloat(amountStr))) {
          logResult(LOCALE === 'zh' ? 'ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑÈáëÈ¢ù' : 'Please enter a valid amount', 'error')
          return
        }

        const amountWei = BigInt(Math.floor(parseFloat(amountStr) * 1e18))
        const valueHex = '0x' + amountWei.toString(16)

        logResult(LOCALE === 'zh' ? `ÂèëÈÄÅ ${amountStr} ETH Âà∞ ${toAddress.slice(0,8)}...` : `Sending ${amountStr} ETH to ${toAddress.slice(0,8)}...`, 'info')

        const txHash = await provider.request({
          method: 'eth_sendTransaction',
          params: [{
            from: account,
            to: toAddress,
            value: valueHex,
          }],
        })
        logResult(LOCALE === 'zh' ? `‰∫§ÊòìÂìàÂ∏å: ${txHash}` : `Transaction hash: ${txHash}`)
      } catch (error) {
        logResult(LOCALE === 'zh' ? `ÈîôËØØ: ${error.message}` : `Error: ${error.message}`, 'error')
      }
    }

    // ==================== Custom Contract Call ====================

    // Store parsed ABI methods
    let parsedAbiMethods = []
    let selectedMethod = null

    // Parse ABI and populate method selector
    window.parseContractAbi = function() {
      const abiText = document.getElementById('contractAbi').value.trim()
      const container = document.getElementById('abiMethodsContainer')
      const select = document.getElementById('abiMethodSelect')
      const paramsContainer = document.getElementById('methodParamsContainer')

      parsedAbiMethods = []
      selectedMethod = null
      paramsContainer.innerHTML = ''

      if (!abiText) {
        container.classList.add('hidden')
        logResult(LOCALE === 'zh' ? 'ËØ∑ËæìÂÖ• ABI' : 'Please enter ABI', 'error')
        return
      }

      try {
        const abi = JSON.parse(abiText)

        if (!Array.isArray(abi)) {
          throw new Error('ABI must be an array')
        }

        // Filter for functions only
        parsedAbiMethods = abi.filter(item =>
          item.type === 'function' ||
          (!item.type && item.name && item.inputs) // Some ABIs don't have type
        )

        if (parsedAbiMethods.length === 0) {
          throw new Error('No functions found in ABI')
        }

        // Populate select
        select.innerHTML = `<option value="">${LOCALE === 'zh' ? 'ÈÄâÊã©ÊñπÊ≥ï' : 'Select Method'}</option>`
        parsedAbiMethods.forEach((method, index) => {
          const inputTypes = (method.inputs || []).map(i => i.type).join(', ')
          const option = document.createElement('option')
          option.value = index
          option.textContent = `${method.name}(${inputTypes})`
          select.appendChild(option)
        })

        container.classList.remove('hidden')
        logResult(LOCALE === 'zh' ? `Ëß£ÊûêÊàêÂäüÔºåÊâæÂà∞ ${parsedAbiMethods.length} ‰∏™ÊñπÊ≥ï` : `Parsed successfully, found ${parsedAbiMethods.length} methods`, 'info')

      } catch (error) {
        container.classList.add('hidden')
        logResult(LOCALE === 'zh' ? `ABI Ëß£ÊûêÈîôËØØ: ${error.message}` : `ABI parse error: ${error.message}`, 'error')
      }
    }

    // Handle method selection
    window.onMethodSelect = function() {
      const select = document.getElementById('abiMethodSelect')
      const paramsContainer = document.getElementById('methodParamsContainer')
      const btnCall = document.getElementById('btnCallContract')
      const btnSend = document.getElementById('btnSendContract')

      const index = select.value
      if (index === '' || !parsedAbiMethods[index]) {
        selectedMethod = null
        paramsContainer.innerHTML = ''
        btnCall.disabled = true
        btnSend.disabled = true
        return
      }

      selectedMethod = parsedAbiMethods[index]
      renderMethodParams(selectedMethod)

      // Enable/disable buttons based on state mutability
      const isView = selectedMethod.stateMutability === 'view' || selectedMethod.stateMutability === 'pure' || selectedMethod.constant
      const isPayable = selectedMethod.stateMutability === 'payable'

      btnCall.disabled = !provider?.isConnected
      btnSend.disabled = !provider?.isConnected || isView
    }

    // Render parameter inputs for selected method
    function renderMethodParams(method) {
      const container = document.getElementById('methodParamsContainer')
      container.innerHTML = ''

      // Show method info
      const isView = method.stateMutability === 'view' || method.stateMutability === 'pure' || method.constant
      const isPayable = method.stateMutability === 'payable'
      const stateType = isView ? 'view' : (isPayable ? 'payable' : 'nonpayable')
      const stateLabel = isView ? (LOCALE === 'zh' ? 'Âè™ËØª' : 'Read') : (isPayable ? (LOCALE === 'zh' ? 'ÊîØ‰ªò' : 'Payable') : (LOCALE === 'zh' ? 'ÂÜôÂÖ•' : 'Write'))

      const infoDiv = document.createElement('div')
      infoDiv.className = 'method-info'
      infoDiv.innerHTML = `<span class="method-type ${stateType}">${stateLabel}</span>${method.name}`
      container.appendChild(infoDiv)

      // Render inputs
      const inputs = method.inputs || []
      if (inputs.length === 0) {
        const noParams = document.createElement('div')
        noParams.style.cssText = 'font-size: 12px; color: var(--color-text-muted); margin-bottom: 8px;'
        noParams.textContent = LOCALE === 'zh' ? 'Êó†ÂèÇÊï∞' : 'No parameters'
        container.appendChild(noParams)
      } else {
        inputs.forEach((input, idx) => {
          const paramDiv = document.createElement('div')
          paramDiv.className = 'method-param'

          const label = document.createElement('label')
          label.textContent = input.name || `param${idx}`

          const typeSpan = document.createElement('span')
          typeSpan.className = 'param-type'
          typeSpan.textContent = input.type

          const inputEl = document.createElement('input')
          inputEl.type = 'text'
          inputEl.className = 'form-input'
          inputEl.id = `param_${idx}`
          inputEl.placeholder = getPlaceholder(input.type)
          inputEl.style.flex = '1'

          paramDiv.appendChild(label)
          paramDiv.appendChild(typeSpan)
          paramDiv.appendChild(inputEl)
          container.appendChild(paramDiv)
        })
      }

      // Add value input for payable functions
      if (isPayable) {
        const valueDiv = document.createElement('div')
        valueDiv.className = 'method-param'
        valueDiv.innerHTML = `
          <label style="color: var(--color-warning);">value</label>
          <span class="param-type">ETH</span>
          <input type="text" class="form-input" id="param_value" placeholder="0.0" style="flex: 1;">
        `
        container.appendChild(valueDiv)
      }
    }

    // Get placeholder text based on type
    function getPlaceholder(type) {
      if (type === 'address') return '0x...'
      if (type.startsWith('uint') || type.startsWith('int')) return '0'
      if (type === 'bool') return 'true / false'
      if (type.startsWith('bytes')) return '0x...'
      if (type === 'string') return 'text'
      if (type.includes('[]')) return '[item1, item2, ...]'
      return ''
    }

    // Encode function call data
    function encodeFunctionCall(method) {
      const inputs = method.inputs || []
      const params = []

      // Get parameter values
      for (let i = 0; i < inputs.length; i++) {
        const input = inputs[i]
        const value = document.getElementById(`param_${i}`).value.trim()
        params.push(parseParamValue(value, input.type))
      }

      // Calculate function selector (first 4 bytes of keccak256)
      const signature = `${method.name}(${inputs.map(i => i.type).join(',')})`
      const selector = keccak256(signature).slice(0, 10)

      // Encode parameters
      const encodedParams = encodeParams(inputs, params)

      return selector + encodedParams
    }

    // Parse parameter value based on type
    function parseParamValue(value, type) {
      if (type === 'bool') {
        return value.toLowerCase() === 'true' || value === '1'
      }
      if (type === 'address') {
        return value
      }
      if (type.startsWith('uint') || type.startsWith('int')) {
        return BigInt(value)
      }
      if (type.includes('[]')) {
        try {
          return JSON.parse(value)
        } catch {
          return value.split(',').map(v => v.trim())
        }
      }
      return value
    }

    // Simple keccak256 implementation (first 4 bytes for function selector)
    function keccak256(str) {
      // Using Web Crypto API isn't available for keccak256
      // We'll use a simple implementation for function selector
      // In production, use ethers.js or web3.js

      // Simple keccak256 hash using a minimal implementation
      const utf8 = new TextEncoder().encode(str)
      return keccak256Bytes(utf8)
    }

    // Minimal Keccak-256 implementation
    function keccak256Bytes(data) {
      const KECCAK_ROUNDS = 24
      const RC = [
        0x0000000000000001n, 0x0000000000008082n, 0x800000000000808an, 0x8000000080008000n,
        0x000000000000808bn, 0x0000000080000001n, 0x8000000080008081n, 0x8000000000008009n,
        0x000000000000008an, 0x0000000000000088n, 0x0000000080008009n, 0x000000008000000an,
        0x000000008000808bn, 0x800000000000008bn, 0x8000000000008089n, 0x8000000000008003n,
        0x8000000000008002n, 0x8000000000000080n, 0x000000000000800an, 0x800000008000000an,
        0x8000000080008081n, 0x8000000000008080n, 0x0000000080000001n, 0x8000000080008008n
      ]

      const ROTATIONS = [
        [0, 36, 3, 41, 18], [1, 44, 10, 45, 2], [62, 6, 43, 15, 61],
        [28, 55, 25, 21, 56], [27, 20, 39, 8, 14]
      ]

      // Padding
      const rate = 136 // bytes (1088 bits for keccak256)
      const padded = new Uint8Array(Math.ceil((data.length + 1) / rate) * rate)
      padded.set(data)
      padded[data.length] = 0x01
      padded[padded.length - 1] |= 0x80

      // State
      const state = Array(5).fill(null).map(() => Array(5).fill(0n))

      // Absorb
      for (let i = 0; i < padded.length; i += rate) {
        for (let j = 0; j < rate && j < 25 * 8; j += 8) {
          const x = (j / 8) % 5
          const y = Math.floor((j / 8) / 5)
          let val = 0n
          for (let k = 0; k < 8 && i + j + k < padded.length; k++) {
            val |= BigInt(padded[i + j + k]) << BigInt(k * 8)
          }
          state[x][y] ^= val
        }

        // Permutation
        for (let round = 0; round < KECCAK_ROUNDS; round++) {
          // Theta
          const C = Array(5).fill(0n)
          const D = Array(5).fill(0n)
          for (let x = 0; x < 5; x++) {
            for (let y = 0; y < 5; y++) C[x] ^= state[x][y]
          }
          for (let x = 0; x < 5; x++) {
            D[x] = C[(x + 4) % 5] ^ rotl64(C[(x + 1) % 5], 1n)
          }
          for (let x = 0; x < 5; x++) {
            for (let y = 0; y < 5; y++) state[x][y] ^= D[x]
          }

          // Rho and Pi
          const B = Array(5).fill(null).map(() => Array(5).fill(0n))
          for (let x = 0; x < 5; x++) {
            for (let y = 0; y < 5; y++) {
              B[y][(2 * x + 3 * y) % 5] = rotl64(state[x][y], BigInt(ROTATIONS[x][y]))
            }
          }

          // Chi
          for (let x = 0; x < 5; x++) {
            for (let y = 0; y < 5; y++) {
              state[x][y] = B[x][y] ^ ((~B[(x + 1) % 5][y]) & B[(x + 2) % 5][y])
            }
          }

          // Iota
          state[0][0] ^= RC[round]
        }
      }

      // Squeeze (32 bytes for keccak256)
      let hash = '0x'
      for (let i = 0; i < 4; i++) {
        const x = i % 5
        const y = Math.floor(i / 5)
        for (let j = 0; j < 8; j++) {
          hash += ((state[x][y] >> BigInt(j * 8)) & 0xffn).toString(16).padStart(2, '0')
        }
      }
      return hash
    }

    function rotl64(x, n) {
      n = n % 64n
      return ((x << n) | (x >> (64n - n))) & 0xffffffffffffffffn
    }

    // Encode ABI parameters (simplified - handles common types)
    function encodeParams(inputs, values) {
      let result = ''

      for (let i = 0; i < inputs.length; i++) {
        const type = inputs[i].type
        const value = values[i]

        if (type === 'address') {
          result += value.slice(2).toLowerCase().padStart(64, '0')
        } else if (type.startsWith('uint') || type.startsWith('int')) {
          const bn = BigInt(value)
          const hex = bn.toString(16)
          result += hex.padStart(64, '0')
        } else if (type === 'bool') {
          result += (value ? '1' : '0').padStart(64, '0')
        } else if (type.startsWith('bytes') && !type.includes('[]')) {
          // Fixed bytes
          const hex = value.startsWith('0x') ? value.slice(2) : value
          result += hex.padEnd(64, '0')
        } else {
          // For complex types, just log a warning
          console.warn(`Type ${type} encoding not fully supported`)
          result += '0'.repeat(64)
        }
      }

      return result
    }

    // Decode return value (simplified)
    function decodeReturnValue(data, outputs) {
      if (!outputs || outputs.length === 0) return data

      const results = []
      let offset = 2 // skip 0x

      for (const output of outputs) {
        const chunk = data.slice(offset, offset + 64)
        offset += 64

        if (output.type === 'address') {
          results.push('0x' + chunk.slice(24))
        } else if (output.type.startsWith('uint') || output.type.startsWith('int')) {
          results.push(BigInt('0x' + chunk).toString())
        } else if (output.type === 'bool') {
          results.push(parseInt(chunk, 16) !== 0)
        } else if (output.type === 'string' || output.type === 'bytes') {
          results.push('0x' + chunk) // Simplified - dynamic types need more handling
        } else {
          results.push('0x' + chunk)
        }
      }

      return results.length === 1 ? results[0] : results
    }

    // Call contract (read)
    window.testCallContract = async function() {
      if (!selectedMethod) {
        logResult(LOCALE === 'zh' ? 'ËØ∑ÂÖàÈÄâÊã©ÊñπÊ≥ï' : 'Please select a method first', 'error')
        return
      }

      const contractAddress = document.getElementById('contractAddress').value.trim()
      if (!contractAddress || !contractAddress.match(/^0x[a-fA-F0-9]{40}$/)) {
        logResult(LOCALE === 'zh' ? 'ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑÂêàÁ∫¶Âú∞ÂùÄ' : 'Please enter a valid contract address', 'error')
        return
      }

      try {
        const data = encodeFunctionCall(selectedMethod)
        logResult(LOCALE === 'zh' ? `Ë∞ÉÁî® eth_call: ${selectedMethod.name}...` : `Calling eth_call: ${selectedMethod.name}...`, 'info')

        const result = await provider.request({
          method: 'eth_call',
          params: [{
            to: contractAddress,
            data: data,
          }, 'latest'],
        })

        const decoded = decodeReturnValue(result, selectedMethod.outputs)
        logResult(LOCALE === 'zh' ? `ËøîÂõûÂÄº: ${JSON.stringify(decoded)}` : `Return value: ${JSON.stringify(decoded)}`)
      } catch (error) {
        logResult(LOCALE === 'zh' ? `ÈîôËØØ: ${error.message}` : `Error: ${error.message}`, 'error')
      }
    }

    // Send contract transaction (write)
    window.testSendContract = async function() {
      if (!selectedMethod) {
        logResult(LOCALE === 'zh' ? 'ËØ∑ÂÖàÈÄâÊã©ÊñπÊ≥ï' : 'Please select a method first', 'error')
        return
      }

      const contractAddress = document.getElementById('contractAddress').value.trim()
      if (!contractAddress || !contractAddress.match(/^0x[a-fA-F0-9]{40}$/)) {
        logResult(LOCALE === 'zh' ? 'ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑÂêàÁ∫¶Âú∞ÂùÄ' : 'Please enter a valid contract address', 'error')
        return
      }

      try {
        const account = getCurrentAccount()
        const data = encodeFunctionCall(selectedMethod)

        const txParams = {
          from: account,
          to: contractAddress,
          data: data,
        }

        // Handle payable value
        const isPayable = selectedMethod.stateMutability === 'payable'
        if (isPayable) {
          const valueInput = document.getElementById('param_value')
          if (valueInput && valueInput.value.trim()) {
            const valueEth = parseFloat(valueInput.value.trim())
            const valueWei = BigInt(Math.floor(valueEth * 1e18))
            txParams.value = '0x' + valueWei.toString(16)
          }
        }

        logResult(LOCALE === 'zh' ? `Ë∞ÉÁî® eth_sendTransaction: ${selectedMethod.name}...` : `Calling eth_sendTransaction: ${selectedMethod.name}...`, 'info')

        const txHash = await provider.request({
          method: 'eth_sendTransaction',
          params: [txParams],
        })

        logResult(LOCALE === 'zh' ? `‰∫§ÊòìÂìàÂ∏å: ${txHash}` : `Transaction hash: ${txHash}`)
      } catch (error) {
        logResult(LOCALE === 'zh' ? `ÈîôËØØ: ${error.message}` : `Error: ${error.message}`, 'error')
      }
    }
  </script>
</body>
</html>
